[{"title":"关于我","url":"/about-me/","content":"Forever remember, no matter how hard the life was, you shouldn’t lose your hope and confidence.\n\n\n\n"},{"title":"axios接收来自SpringBoot的文件流","url":"/development-note/axios-download-file-stream/","content":"\n\n记录一次axios接收文件流的尝试。最近在写一个代码生成工具，涉及到服务器生成代码进行压缩，传给页面进行下载。\n\n后端接口编写后端使用Spring Boot进行接口响应\n@PostMapping(value = &quot;/project/code/download&quot;)@ResponseBodypublic void downloadCode(@RequestBody TProjectInfo pf, HttpServletResponse response) &#123;    // 0. 保存此次生成的项目配置    // 1.生成源码文件    // 2.压缩文件    // 3.设置回复的一些参数    // 4.将压缩文件写入网络流    log.info(&quot;request param: &#123;&#125;&quot;, pf);    projectService.saveOrUpdate(pf);    String filename = &quot;./src/main/resources/templates/test/源码233.zip&quot;;    File file = new File(filename);    // 如果文件存在，则进行下载    if (file.exists()) &#123;        BufferedInputStream bis = null;        OutputStream os = null;        try &#123;            // 配置文件下载            // 下载文件能正常显示中文            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;                    + URLEncoder.encode(file.getName(), &quot;UTF-8&quot;));            response.setHeader(&quot;content-type&quot;, &quot;application/octet-stream&quot;);            response.setContentType(&quot;application/octet-stream&quot;);            // 实现文件下载            byte[] buffer = new byte[1024];            bis = new BufferedInputStream(Files.newInputStream(file.toPath()));            os = response.getOutputStream();            int i = bis.read(buffer);            while (i != -1) &#123;                os.write(buffer, 0, i);                i = bis.read(buffer);            &#125;            log.info(&quot;Download  successfully!&quot;);        &#125; catch (Exception e) &#123;            log.error(&quot;Download  failed: &#123;&#125;&quot;, e.getMessage());        &#125; finally &#123;            if (os != null) &#123;                try &#123;                    os.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (bis != null) &#123;                try &#123;                    bis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n接口返回data：\n\n\naxios接收并下载assit.post(&#x27;/project/code/download&#x27;, obj, &#123;    responseType: &#x27;blob&#x27;,  // 此处必须设置    onDownloadProgress: function (pe) &#123;    // Do whatever you want with the native progress event    console.log(Math.round(pe.loaded / pe.total * 100) + &#x27;%&#x27;)&#125;&#125;).then(r =&gt; &#123;    const blob = new Blob([r.data]); // &#123; type: &quot;application/vnd.ms-excel&quot; &#125;    let url = URL.createObjectURL(blob); // 创建一个临时的url指向blob对象    // 创建url之后可以模拟对此文件对象的一系列操作，例如：预览、下载    const a = document.createElement(&quot;a&quot;);    a.download = obj.projectName + &quot;.zip&quot;;    a.style.display = &quot;none&quot;    a.href = url;    document.body.appendChild(a)    a.click();    // 释放这个临时的对象url    URL.revokeObjectURL(url);    document.body.removeChild(a)&#125;).catch(e =&gt; &#123;    console.log(e)&#125;)\n\n错误记录\naxios请求时未配置 responseType: &#39;blob&#39;，虽然能正常下载，但是会出现数据格式错误：\n\n\nTo-Do\n axios实时监听下载进度\n\n","categories":["研发笔记"],"tags":["axios","文件下载"]},{"title":"云服务器开发笔记","url":"/development-note/cloud-server-usage-note/","content":"\n本文档是记录使用阿里云服务器搭建自己的网站和应用的使用记录\n系统：Centos7.6\n内核：3.10.0-1160.49.1.el7.x86_64\n\n1. 配置PS1及命令别名在自己的家目录下的.bashrc文件里添加： \n# 定制自己的快捷命令alias rm=&#x27;rm -i&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;alias cls=&#x27;clear&#x27;# 设置提示符PS1=&quot;[\\[\\e[36;40m\\]\\u@\\[\\e[31;40m\\]\\h \\[\\e[33;40m\\]\\w\\[\\e[0m\\]]\\$ &quot;\n\n运行一下该文件：\nsource ~/.bashrc\n\n\n\n2. 安装jdk82.1 官网下载jdk8\n清华大学镜像：OpenJDK \nOracle官网，需登录：OracleJDK\n\n2.2 解压tar -zxvf [压缩包] -C [解压目录]\n\n2.3 配置环境变量vim &#x2F;etc&#x2F;profile，在最后添加以下内容：\nJAVA_HOME=[解压后的jdk根目录]PATH=$&#123;JAVA_HOME&#125;/bin:$PATHexport JAVA_HOME PATH\n\n运行profile文件：\nsource /etc/profile\n\n3. 安装docker容器\n参考链接：https://www.cnblogs.com/yufeng218/p/8370670.html\n\n安装docker需要使用root权限\n\n先更新yum包\nsudo yum update\n\n卸载旧版本\nsudo yum remove docker  docker-common docker-selinux docker-engine\n\n安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n\n设置yum源\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n可以先查看所有仓库中所有docker版本，并选择特定版本安装\nyum list docker-ce --showduplicates | sort -r\n\n安装docker\n#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版sudo yum install docker-ce\n\n启动并加入开机启动\nsudo systemctl start dockersudo systemctl enable docker\n\n查看docker的版本\ndocker version\n\n至此，docker安装成功！\n\n\n4. 使用docker安装mysql\ndocker命令参考：https://www.runoob.com/docker/docker-command-manual.html\n\n\n安装\ndocker search mysql #搜索mysql库中的版本docker pull mysql   #安装最新版稳定版的mysqldocker iamges       #查看docker已安装的镜像（软件）\n\n启动mysql，并映射到本地的3306端口\n# 通过镜像运行软件docker run mysql[:版本号，默认为最新版] -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=[你的密码]# 查看docker中正在运行的软件docker ps\n\n进入mysql，并配置远程登录用户\n# 以交互模式进入mysqldocker exec -it mysql bash# 以下命令都是在docker控制台运行的mysql -u root -p # 回车后，输入你刚刚设置的额mysql root 用户的密码即可# 创建mysql user，并设置成远程可登录及远程登录密码create user &#x27;用户名&#x27;@&#x27;%&#x27; identified by &#x27;用户密码&#x27;;# 赋予权限grant all on *.* to &#x27;用户名&#x27;@&#x27;%&#x27; identified by &#x27;用户密码&#x27;;#刷新权限池flush privileges;\n\n至此，就可以通过【本机的ip + 3306端口 + 远程登录用户和密码】就能远程连接MySQL了！\n\n\n5. 运行jarnohup java -jar [你的jar包] &gt; [输出文件（日志）] 2&gt;&amp;1 &amp;\n\n\n2&gt;&amp;1解释：\n\n查看输出文件：\ntail -f [输出文件]\n\n验证服务是否启动成功：\nps aux | grep java\n\n\n\n6. 安装nginxnginx服务器是一个轻量级的、操作方便，可实现正向和反向代理，基本每个开发者都不会陌生的一个web服务器。本文以压缩包安装为例！\n\n官网：https://nginx.org/en/\n中文文档：https://www.nginx.cn/doc/\n\n6.1 安装yum install nginx\n\n6.2 配置配置代理，找到配置文件/etc/nginx/nginx.conf，找到server模块：\n6.3 相关命令# 重启/启动/停止/查看状态systemctl restart/start/stop/status nginx# 重新加载配置文件nginx -s reload nginx -s reopen #重启Nginxnginx -s reload #重新加载Nginx配置文件，然后以优雅的方式重启Nginxnginx -s stop #强制停止Nginx服务nginx -s quit #优雅地停止Nginx服务（即处理完所有请求后再停止服务）nginx -t #检测配置文件是否有语法错误，然后退出nginx -?,-h #打开帮助信息nginx -v #显示版本信息并退出nginx -V #显示版本和配置选项信息，然后退出nginx -t #检测配置文件是否有语法错误，然后退出nginx -T #检测配置文件是否有语法错误，转储并退出nginx -q #在检测配置文件期间屏蔽非错误信息nginx -p prefix #设置前缀路径(默认是:/usr/share/nginx/)nginx -c filename #设置配置文件(默认是:/etc/nginx/nginx.conf)nginx -g directives #设置配置文件外的全局指令killall nginx #杀死所有nginx进程\n\n6.4 可能遇到的问题\n能访问 index页面，根据路由也进入下一个页面，但是在路由到的页面上刷新会出现404，需要在nginx配置文件中加入，通过路由进行导航：server &#123;\tlisten       80;    listen       [::]:80;    server_name  _;    root         /usr/share/nginx/html/guan-web;    **try_files $uri $uri/ /index.html;** --- 防止刷新页面出现404    # Load configuration files for the default server block.    include /etc/nginx/default.d/*.conf;    location /auth-local &#123;        proxy_pass      http://127.0.0.1:8000/;\t&#125;    location /favorite-api &#123;        proxy_pass      http://127.0.0.1:9000/;\t&#125;    error_page 404 /404.html;        location = /404.html &#123;\t&#125;    error_page 500 502 503 504 /50x.html;        location = /50x.html &#123;\t&#125;&#125;\n\n7. 使用docker安装redis\n参考链接：https://cloud.tencent.com/developer/article/1670205\nredis 官网：http://www.redis.cn/\n\n# 获取镜像docker pull redis# 启动docker run -p 6379:6379 --name redis -v /usr/local/soft/redis/redis.conf:/etc/redis/redis.conf  -v /usr/local/soft/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes#查看启动日志docker logs redis#交互运行docker exec -it redis redis-cli\n\n\nredis.conf配置文件：bind 127.0.0.1 \t\t\t#注释掉这部分，使redis可以外部访问daemonize no   \t\t\t#用守护线程的方式启动requirepass 你的密码\t #给redis设置密码appendonly yes \t\t    #redis持久化　　默认是notcp-keepalive 300       #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300\n\n8. 配置jar包启动|关闭|重启的shell脚本启动脚本在开发和测试阶段还是很方便的，可大大提升开发效率，因为这样可以不用每次提交代码后去手动敲复杂的启动命令\n#!/bin/bash#替换为你自己的执行jar包，其他代码无需更改APP_NAME=guan-auth-1.0.jar# 第三方jar包所在路径CLASS_LIB_PATH=/root/workspace/myjars/lib/JAR_PATH=/root/workspace/myjars/authOUT_FILE=/root/workspace/logs/auth/guan-auth.out#使用说明，用来提示输入参数usage() &#123;    echo &quot;Usage: sh 脚本名.sh [start|stop|restart|status]&quot;    exit 1&#125;#检查程序是否在运行is_exist()&#123;  pid=`ps -ef|grep $APP_NAME|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; `  #如果不存在返回1，存在返回0  if [ -z &quot;$&#123;pid&#125;&quot; ]; then   return 1  else    return 0  fi&#125;#启动方法start() &#123;  is_exist  if [ $? -eq &quot;0&quot; ]; then    echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot;  else  \t# 因为在打包时，把所有的第三方jar全部抽取出来了（减少打包的体积），所以启动的时候需要加上 -Dloader.path 参数    nohup java -Dloader.path=$CLASS_LIB_PATH -jar $JAR_PATH/$APP_NAME &gt; $OUT_FILE 2&gt;&amp;1 &amp;    echo &quot;$&#123;APP_NAME&#125; start success&quot;  fi&#125;#停止方法stop() &#123;  is_exist  if [ $? -eq &quot;0&quot; ]; then    kill -9 $pid  else    echo &quot;$&#123;APP_NAME&#125; is not running&quot;  fi&#125;#输出运行状态status() &#123;  is_exist  if [ $? -eq &quot;0&quot; ]; then    echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot;  else    echo &quot;$&#123;APP_NAME&#125; is NOT running.&quot;  fi&#125;#重启restart() &#123;  stop  start&#125;#根据输入参数，选择执行对应方法，不输入则执行使用说明case &quot;$1&quot; in  &quot;start&quot;)    start    ;;  &quot;stop&quot;)    stop    ;;  &quot;status&quot;)    status    ;;  &quot;restart&quot;)    restart    ;;  *)    usage    ;;esac# 参考： https://www.cnblogs.com/chywx/p/10460061.html\n\n\n使用\nsh [你的脚本] [restart|stop|start|status]\n\n在idea中配置插件Alibaba Cloud Tookit自动部署运行如下图：\n\n\n","categories":["研发笔记"],"tags":["Java","环境搭建","云服务器"]},{"title":"Git自动化执行脚本","url":"/development-note/git-auto-bash/","content":"前言最近碰到一个有意思的想法，由于每次更新博客都要提交代码，每次都要git add、git commit、git push，显得比较繁琐，于是写了一个交互式提交脚本。\n我的初步实现#!/bin/bashusage() &#123;\techo &quot;&quot;\techo -e &quot;\\e[91m缺少必要的参数：\\e[0m&quot;\techo &quot;* 参数说明 *&quot;\techo &quot;  commit  本地提交代码&quot;\techo &quot;  pull    拉取远程代码&quot;\techo &quot;  push    推送本地代码&quot;\techo &quot;&quot;\techo &quot;&quot;&#125;# 查看当前仓库有无提交，验证其是否为一个合法的 git 仓库check() &#123;\tgit status\tif [ $? == &quot;0&quot; ]\tthen\t\t$1\telse\t\techo -e &quot;\\n\\e[91m当前目录不是git仓库，请将脚本移动到git仓库下执行\\e[0m\\n&quot;\t\texit -1\tfi&#125;# 确认是否先本地提交代码confirm() &#123;\techo &quot;&quot;    read -p &quot;是否先提交本地代码? (y/n): &quot; c\t    case $c in        [yY][eE][sS]|[yY])            $1 &amp;&amp; $2            ;;\t\t*)\t\t\t$2    esac&#125;# 提交代码到本地仓库commit() &#123;\techo -e &quot;\\n* 提交代码到本地仓库\\n&quot;\tread -p &quot;输入提交信息: &quot; msg\t\tgit add .        git commit -m &quot;$&#123;msg&#125;&quot; --no-verify&#125;# 执行拉取pull() &#123;\tconfirm commit pullOrigin&#125;# 拉取远程仓库分支代码pullOrigin() &#123;\techo &quot;&quot;    # 输入拉取远程仓库的分支名称    read -p &quot;输入远程仓库的分支(默认按Enter): &quot; br\techo -e &quot;\\n* 开始拉取代码...&quot;    if [ &quot;$br&quot; != &quot;&quot; ]    then        git pull origin $br    else        git pull    fi&#125;# 执行推送push() &#123;    confirm commit pushOrigin&#125;# 推送到远程分支代码pushOrigin() &#123;    # 输入推到远程仓库的分支名称    read -p &quot;输入远程仓库的分支(默认按Enter): &quot; br\techo -e &quot;\\n* 开始推送代码...&quot;    if [ &quot;$br&quot; != &quot;&quot; ]    then         git push origin $br    else        git push    fi&#125;case $1 in\t[cC][oO][mM][mM][iI][tT])\t\tcheck commit\t\t;;\t[pP][uU][lL][lL])\t\tcheck pull\t\t;;\t[pP][uU][sS][hH])\t\tcheck push\t\t;;\t*)\t\tusageesac\n\nWindows 用户可以使用 Git Bash 工具运行该脚本！\n\n测试：\n\n写在最后\n 考虑全自动实现，减少交互\n 提交 Message 考虑调 类似vim或记事本进行录入\n 部署成定时任务（前提是要租一个服务器）\n\n","categories":["研发笔记"],"tags":["Git","Bash脚本"]},{"title":"Code Highlight Style test","url":"/efficiency-work/code-highlight/","content":"Make sure all the code blocks highlighted correctly. All the code samples are come from the demo of https://highlightjs.org\n\n\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&#x27;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\n\n#[derive(Debug)]pub enum State &#123;    Start,    Transient,    Closed,&#125;impl From&lt;&amp;&#x27;a str&gt; for State &#123;    fn from(s: &amp;&#x27;a str) -&gt; Self &#123;        match s &#123;            &quot;start&quot; =&gt; State::Start,            &quot;closed&quot; =&gt; State::Closed,            _ =&gt; unreachable!(),        &#125;    &#125;&#125;\n\n[  &#123;    &quot;title&quot;: &quot;apples&quot;,    &quot;count&quot;: [12000, 20000],    &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125;  &#125;,  &#123;    &quot;title&quot;: &quot;oranges&quot;,    &quot;count&quot;: [17500, null],    &quot;description&quot;: &#123;&quot;text&quot;: &quot;...&quot;, &quot;sensitive&quot;: false&#125;  &#125;]\n\n@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0):    r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;    if param1 &gt; param2: # interesting        print &#x27;Gre\\&#x27;ater&#x27;    return (param2 - param1 + 1 + 0b10l) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27;\n\n&lt;!DOCTYPE html&gt;&lt;title&gt;Title&lt;/title&gt;&lt;style&gt;body &#123;width: 500px;&#125;&lt;/style&gt;&lt;script type=&quot;application/javascript&quot;&gt;  function $init() &#123;return true;&#125;&lt;/script&gt;&lt;body&gt;  &lt;p checked class=&quot;title&quot; id=&#x27;title&#x27;&gt;Title&lt;/p&gt;  &lt;!-- here goes the rest of the page --&gt;&lt;/body&gt;\n\nfunction $initHighlight(block, cls) &#123;  try &#123;    if (cls.search(/\\bno\\-highlight\\b/) != -1)      return process(block, true, 0x0F) +             ` class=&quot;$&#123;cls&#125;&quot;`;  &#125; catch (e) &#123;    /* handle exception */  &#125;  for (var i = 0 / 2; i &lt; classes.length; i++) &#123;    if (checkCondition(classes[i]) === undefined)      console.log(&#x27;undefined&#x27;);  &#125;  return (    &lt;div&gt;      &lt;web-component&gt;&#123;block&#125;&lt;/web-component&gt;    &lt;/div&gt;  )&#125;export $initHighlight;\n\n#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123;  /* An annoying &quot;Hello World&quot; example */  for (auto i = 0; i &lt; 0xFFFF; i++)    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;  char c = &#x27;\\n&#x27;;  unordered_map &lt;string, vector&lt;string&gt; &gt; m;  m[&quot;key&quot;] = &quot;\\\\\\\\&quot;; // this is an error  return -2e3 + 12l;&#125;\n\nCREATE TABLE &quot;topic&quot; (    &quot;id&quot; serial NOT NULL PRIMARY KEY,    &quot;forum_id&quot; integer NOT NULL,    &quot;subject&quot; varchar(255) NOT NULL);ALTER TABLE &quot;topic&quot;ADD CONSTRAINT forum_id FOREIGN KEY (&quot;forum_id&quot;)REFERENCES &quot;forum&quot; (&quot;id&quot;);-- Initialsinsert into &quot;topic&quot; (&quot;forum_id&quot;, &quot;subject&quot;)values (2, &#x27;D&#x27;&#x27;artagnian&#x27;);\n\n#import &lt;UIKit/UIKit.h&gt;#import &quot;Dependency.h&quot;@protocol WorldDataSource@optional- (NSString*)worldName;@required- (BOOL)allowsToLive;@end@property (nonatomic, readonly) NSString *title;- (IBAction) show;@end\n\n/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123;  public static final Short ERROR = 0x0001;  public void moveTo(int x, int y, int z) &#123;    _ai = null;    log(&quot;Should not be called&quot;);    if (1 &gt; 5) &#123; // wtf!?      return;    &#125;  &#125;&#125;\n\nimport Foundation@objc class Person: Entity &#123;  var name: String!  var age:  Int!  init(name: String, age: Int) &#123;    /* /* ... */ */  &#125;  // Return a descriptive string for this person  func description(offset: Int = 0) -&gt; String &#123;    return &quot;\\(name) is \\(age + offset) years old&quot;  &#125;&#125;\n\n@font-face &#123;  font-family: Chunkfive; src: url(&#x27;Chunkfive.otf&#x27;);&#125;body, .usertext &#123;  color: #F0F0F0; background: #600;  font-family: Chunkfive, sans;&#125;@import url(print.css);@media print &#123;  a[href^=http]::after &#123;    content: attr(href)  &#125;&#125;\n\n# The Greeter classclass Greeter  def initialize(name)    @name = name.capitalize  end  def salute    puts &quot;Hello #&#123;@name&#125;!&quot;  endendg = Greeter.new(&quot;world&quot;)g.salute\n\n# MakefileBUILDDIR      = _buildEXTRAS       ?= $(BUILDDIR)/extras.PHONY: main cleanmain:\t@echo &quot;Building main facility...&quot;\tbuild_main $(BUILDDIR)clean:\trm -rf $(BUILDDIR)/*\n\npackage mainimport &quot;fmt&quot;func main() &#123;    ch := make(chan float64)    ch &lt;- 1.0e10    // magic number    x, ok := &lt;- ch    defer fmt.Println(`exitting now\\`)    go println(len(&quot;hello world!&quot;))    return&#125;\n\n#!/bin/bash###### CONFIGACCEPTED_HOSTS=&quot;/root/.hag_accepted.conf&quot;BE_VERBOSE=falseif [ &quot;$UID&quot; -ne 0 ]then  echo &quot;Superuser rights required&quot;  exit 2figenApacheConf()&#123;  echo -e &quot;# Host $&#123;HOME_DIR&#125;$1/$2 :&quot;&#125;\n\n; boilerplate[package]name = &quot;some_name&quot;authors = [&quot;Author&quot;]description = &quot;This is \\a description&quot;[[lib]]name = $&#123;NAME&#125;default = Trueauto = nocounter = 1_000\n","categories":["效率办公"]},{"title":"Markdown Style test","url":"/efficiency-work/markdown/","content":"This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly.\n\n\n\nHeaders# H1## H2### H3#### H4##### H5###### H6Alternatively, for H1 and H2, an underline-ish style:Alt-H1======Alt-H2------\n\nH1H2H3H4H5H6Alternatively, for H1 and H2, an underline-ish style:\nAlt-H1Alt-H2EmphasisEmphasis, aka italics, with *asterisks* or _underscores_.Strong emphasis, aka bold, with **asterisks** or __underscores__.Combined emphasis with **asterisks and _underscores_**.Strikethrough uses two tildes. ~~Scratch this.~~\n\nEmphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLists1. First ordered list item2. Another item  * Unordered sub-list.1. Actual numbers don&#x27;t matter, just that it&#x27;s a number  1. Ordered sub-list4. And another item.   You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown).   To have a line break without a paragraph, you will need to use two trailing spaces.     Note that this line is separate, but within the same paragraph.     (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)* Unordered list can use asterisks- Or minuses+ Or pluses- Paragraph In unordered list  For example like this.Common Paragraph with some text.And more text.\n\n\nFirst ordered list item\nAnother item\n\n\nUnordered sub-list.\n\n\nActual numbers don’t matter, just that it’s a number\n\nOrdered sub-list\n\nAnd another item.\nYou can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we’ll use three here to also align the raw Markdown).\nTo have a line break without a paragraph, you will need to use two trailing spaces.Note that this line is separate, but within the same paragraph.(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)\n\n\n\nUnordered list can use asterisks\n\n\nOr minuses\n\n\nOr pluses\n\n\nParagraph In unordered list\nFor example like this.\n\n\nCommon Paragraph with some text.And more text.\nInline HTML&lt;p&gt;To reboot your computer, press &lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;.&lt;/p&gt;\n\nTo reboot your computer, press ctrl+alt+del.\n\n\n&lt;dl&gt;    &lt;dt&gt;Definition list&lt;/dt&gt;    &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt;    &lt;dt&gt;Markdown in HTML&lt;/dt&gt;    &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;&lt;/dl&gt;\n\n\n\n    Definition list\n    Is something people use sometimes.\n\n&lt;dt&gt;Markdown in HTML&lt;/dt&gt;\n&lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;\n\n\n\n\nLinks[I&#x27;m an inline-style link](https://www.google.com)[I&#x27;m an inline-style link with title](https://www.google.com &quot;Google&#x27;s Homepage&quot;)[I&#x27;m a reference-style link][Arbitrary case-insensitive reference text][I&#x27;m a relative reference to a repository file](../blob/master/LICENSE)[You can use numbers for reference-style link definitions][1]Or leave it empty and use the [link text itself]Some text to show that the reference links can follow later.[arbitrary case-insensitive reference text]: https://hexo.io[1]: https://hexo.io/docs/[link text itself]: https://hexo.io/api/\n\nI’m an inline-style link\nI’m an inline-style link with title\nI’m a reference-style link\nI’m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself\nSome text to show that the reference links can follow later.\nImageshover to see the title text:Inline-style:![alt text](https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;)Reference-style:![alt text][logo][logo]: https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot;\n\nhover to see the title text:\nInline-style:\n\nReference-style:\nCode and Syntax HighlightingInline code has back-ticks around it.\nvar s = &quot;JavaScript syntax highlighting&quot;;alert(s);\n\ns = &quot;Python syntax highlighting&quot;print s\n\nNo language indicated, so no syntax highlighting.But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;.\n\nTables|                |ASCII                          |HTML                         ||----------------|-------------------------------|-----------------------------||Single backticks|`&#x27;Isn&#x27;t this fun?&#x27;`            |&#x27;Isn&#x27;t this fun?&#x27;            ||Quotes          |`&quot;Isn&#x27;t this fun?&quot;`            |&quot;Isn&#x27;t this fun?&quot;            ||Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n\n\n\n\n\nASCII\nHTML\n\n\n\nSingle backticks\n&#39;Isn&#39;t this fun?&#39;\n‘Isn’t this fun?’\n\n\nQuotes\n&quot;Isn&#39;t this fun?&quot;\n“Isn’t this fun?”\n\n\nDashes\n-- is en-dash, --- is em-dash\n– is en-dash, — is em-dash\n\n\nColons can be used to align columns.\n| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned |  || col 2 is      | centered      |    || zebra stripes | are neat      |   \n\n\n\n\nTables\nAre\nCool\n\n\n\ncol 3 is\nright-aligned\n\n\n\ncol 2 is\ncentered\n\n\n\nzebra stripes\nare neat\n\n\n\nThe outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.\nMarkdown | Less | Pretty--- | --- | ---*Still* | `renders` | **nicely**1 | 2 | 3\n\n\n\n\nMarkdown\nLess\nPretty\n\n\n\nStill\nrenders\nnicely\n\n\n1\n2\n3\n\n\n\nYou can find more information about LaTeX mathematical expressions here.\n\nBlockquotes\nBlockquotes are very handy in email to emulate reply text.This line is part of the same quote.\n\nQuote break.\n\nThis is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.\n\nHorizontal RuleThree or more…\n---Hyphens***Asterisks___Underscores\n\n\nHyphens\n\nAsterisks\n\nUnderscores\nLine BreaksHere&#x27;s a line for us to start with.This line is separated from the one above by two newlines, so it will be a *separate paragraph*.This line is also a separate paragraph, but...This line is only separated by a single newline, so it&#x27;s a separate line in the *same paragraph*.\n\n\nHere’s a line for us to start with.\nThis line is separated from the one above by two newlines, so it will be a separate paragraph.\nThis line is also a separate paragraph, but…This line is only separated by a single newline, so it’s a separate line in the same paragraph.\n\nThis is a regular paragraph.&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph.\n\nThis is a regular paragraph.\n\n    \n        Foo\n    \n\n\nThis is another regular paragraph.\nYoutube videos&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;alt=&quot;IMAGE ALT TEXT HERE&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt;Pure markdown version:[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ARted4RniaU/0.jpg)](https://www.youtube.com/watch?v=ARted4RniaU)\n\n\nPure markdown version:\n\n","categories":["效率办公"]},{"title":"初识Docker","url":"/java/docker-base/","content":"主要介绍在 Centos7 上安装和使用 Docker\n\n\n1. Docker1.1 docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容问题\nDocker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像\nDocker将每个应用放到一个隔离容器中运行，使用沙箱机制，相互隔离\n\n1.2 Docker如何解决开发、测试、生产环境有差异的问题\nDocker镜像中包含完整运行环境，包含系统库函数、仅依赖系统的Linux内核，因此可以在任意操作系统上运行\n\n\nDocker 是一个快速交付应用、运行应用的技术：\n\n可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统\n运行时利用沙箱机制形成隔离容器，各个应用互不干扰\n启动、移除都可以通过一行命令完成，方便快捷\n\n\n2. Docker命令2.1 镜像命令\ndocker images\ndocker pull\ndocker push\ndocker save\ndocker load\n\n2.2 容器命令\ndocker run\ndocker pause\ndocker unpause\ndocker stop\ndocker start\ndocker rm\ndocker exec\ndocker logs\ndocker ps\n\n3. Docker 数据卷\n数据卷是一个虚拟目录，指向宿主文件系统中的某个目录\n\n其作用在于，将数据与容器分离，解耦合，方便操作容器内的数据，保证数据安全！\n3.1 操作数据卷\ndocker volume [COMMAND]\n\ndocker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：\n\ncreate     创建一个volume\ninspect    显示一个或多个volume的信息\nls         列出所有的volume\nprune      删除未使用的volume\nrm         删除一个或多个指定的volume\n\n3.2 挂载数据卷\n-v 数据卷:容器类目录\n\n\ndocker run 命令中通过 -v 参数挂载文件或目录到容器中：\n\n-v volume名称:容器内目录\n-v 宿主机文件:容器内文件\n-v 宿主机目录:容器内目录\n\n\n数据卷挂载与目录直接挂载的区别\n\n数据卷挂载耦合度低，由docker来管理目录；但是目录较深，不便于寻找\n目录挂载耦合度较高，需要手动管理目录；便于寻找\n\n\n\n4. Dockerfile自定义镜像4.1 镜像结构\n镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成\n\n镜像是分层结构，每一层称为一个Layer\n\nBaseImage层：包含基本的系统函数库、环境变量、文件系统\nEntrypoint：入口，是镜像中应用启动的命令\n其他：再BaseImage基础上添加依赖、安装程序、完成整个应用的安装和配置\n\n\n4.2 Dockerfile语法\nDockerfile是一个文本文件，包含若干指令，用指令来说明要执行什么操作来构建镜像。每个指令都会形成一层Layer\n\n\n常见指令\n\n\n\n指令\n说明\n示例\n\n\n\nFROM\n指定基础镜像\nFROM centos:7\n\n\nENV\n设置环境变量，可在后面指令使用\nENV key value\n\n\nCOPY\n拷贝本地文件到镜像的指定目录\nCOPY &#x2F;xxx &#x2F;tmp\n\n\nRUN\n执行Linux的shell命令，一般是安装过程的命令\nRUN yum install gcc\n\n\nEXPOSE\n指定容器运行时监听的端口，提供给镜像使用者\nEXPOSE 8080\n\n\nENTRYPOINT\n镜像中应用的启动命令，容器运行时调用\nENTRYPOINT java -jar xxx.jar\n\n\n更详细语法说明，可参考官方文档：https://docs.docker.com/engine/reference/builder\n\n\n4.3 构建Java项目\n案例：基于java:8-alpine镜像，将一个Java项目构建为镜像\n实现思路如下：\n\n# 指定基础镜像FROM java:8-alpine# 拷贝jar包到容器中COPY ./docker-demo.jar /tmp/app.jar# 暴露端口EXPOSE 8888#入口，java项目启动命令ENTRYPOINT java -jar /tmp/app.jar\n\n5. DockerCompose5.1 DockerCompose是什么它能基于Compose文件快速部署分布式应用，而无需手动一个个创建和运行容器。Compose文件是一个文本文件，通过指令定义集群中每个容器怎么运行。\n\nDockerCompose的语法请参考：https://docs.docker.com/compose/compose-file\n5.2 案例docker-compose文件编写：\nversion: &quot;3.2&quot;services:  nacos:    image: nacos/nacos-server    environment:      MODE: standalone    ports:      - &quot;8848:8848&quot;  mysql:    image: mysql:5.7.25    environment:      MYSQL_ROOT_PASSWORD: 123    volumes:      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;  userservice:    build: ./user-service  orderservice:    build: ./order-service  gateway:    build: ./gateway    ports:      - &quot;10010:10010&quot;\n\n","categories":["Java"],"tags":["Docker"]},{"title":"初识分布式搜索","url":"/java/es-base/","content":"Elastic Search 入门级别教程\n\n官网资料: https://www.elastic.co/guide/index.html\n\n\n\n1. 初识 Elastic SearchElastic Search（以下简称ES）是常用的分布式搜索服务中的中间件，是一款强大的开源搜索引擎，能在海量数据中快速找到目标内容。\nES结合kibana、Logstash、Beats，也就是elastic stack（ELK技术栈）。被广泛应用在日志分析、实时监控等领域。\nES是Elastic Stack的核心，复杂存储、搜索、分析数据。\n\nES底层实现是Lucene，Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。\n\n官网地址：https://lucene.apache.org/\n\n\n\nLucene的优势：\n\n易扩展\n高性能（基于倒排索引）\n\nLucene缺点：\n\n只限于Java语言开发\n学习曲线狭窄\n不支持水平扩展\n\nES的发展\n\n2004年shay Banon基于Lucene开发了Compass\n2010年Shay Banon重写了Compass，取名Elastic Search。\n官网地址：https://www.elastic.co/cn/，目前最新版本8.6\n\n相比于Lucene，ES具备：\n\n支持分布式，可水平扩展\n提供RestAPI接口，可被任何语言调用\n\n为什么要选Elastic Search\n\n\n来源：https://db-engines.com/en/ranking/search+engine\n1.1 倒排索引1.1.1 正向索引和倒排索引传统数据库（如MySQL）采用正向索引，例如当不是根据主键搜索索引失效时，正向索引往往需要全表逐条异议对比才能得到结果集。\n\nES实现上述查询使用倒排索引：\n\n文档（document）：每条数据就是一个文档\n\n词条（term）：文档按照语义分成的词语\n\n\n\n搜索时直接找唯一词条索引即可：\n\n因此。倒排索引更适用于根据文档内容查找，故在搜索引擎中广泛使用。\n1.2 ES的一些概念1.2.1 文档ES是面向文档存储的，可以使数据库中的一条商品数据，一个订单信息。文档数据灰分序列化为json格式后，存储在ES中。\n1.2.2 字段Json文档中的字段（key）\n1.2.3 索引和映射\n索引（index）：相同类型文档的集合\n\n映射（mapping）：索引中文档字段约束信息，类似表的结构约束\n\n\n比如：\n\n1.2.4 概念对比\n然而，并不是说ES可以完全替代MySQL，而是在某些方面比MySQL做得更好，且MySQL也有自己的优势，一般在优秀的架构中，两者都会存在，各自负责自己擅长的部分，相辅相成。\n\nMySQL：擅长事务（定义了ACID）类型操作，可以确保数据的安全和一致性\n\nES：擅长海量数据搜索、分析、计算\n\n\n\n1.3 安装ES、kibana\n以下演示Docker上安装单节点的ES\nES：7.16.3\nKibana：7.16.3\nES和Kibana的版本一定要一致！！！\n\n1.3.1 下载Elastic Search：https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-16-3\nKibana：https://www.elastic.co/cn/downloads/past-releases/kibana-7-16-3\ndocker pull elasticsearch:7.16.3docker pull kibana:7.16.3\n\n\n1.3.2 安装\n创建一个虚拟网络，因为Kibana要与ES在同一个网络\ndocker network create es-network\n\n1.3.2.1 安装和部署ES\n运行docker命令，部署单点ES：\ndocker run -d \\\t--name es \\\t-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\\t-e &quot;discovery.type=single-node&quot; \\\t-v es-data:/usr/share/elasticsearch/data \\\t-v es-plugins:/usr/share/elasticsearch/plugins \\\t--privileged \\\t--network es-network \\\t-p 9200:9200 \\\t-p 9300:9300 \\elasticsearch:7.16.3\n\n命令解释：\n\n-e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称\n-e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问\n-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小\n-e &quot;discovery.type=single-node&quot;：非集群模式\n-v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录\n-v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录\n-v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录\n--privileged：授予逻辑卷访问权\n--network es-net ：加入一个名为es-net的网络中\n-p 9200:9200：端口映射配置\n\n访问出现以下，就说明启动成功：\n\n\n\n1.3.2.1 安装和部署 Kibanakibana可以给提供一个elasticsearch的可视化界面。\n\n运行docker命令，部署Kibana\ndocker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-network \\-p 5601:5601  \\kibana:7.16.3\n\n\n--network es-network ：加入一个名为es-network的网络中，与ES在同一个网络中\n-e &quot;ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置ES的地址，因为kibana已经与ES在一个网络，因此可以用容器名直接访问ES\n-p 5601:5601：端口映射配置\n\n\n访问5601端口能进去以下界面，说明Kibana暂时安装没问题：\n\n\n打开左侧菜单栏，找到Management -&gt; Dev Tools，这是Kibana中提供了一个DevTools界面：\n\n这个界面中可以编写DSL来操作ES。并且对DSL语句有自动补全功能。\n\n\n1.4 分词器ES在创建倒排索引时需要对文档先进行分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理不友好。在Kibana中的DevTools测试：\n\n由上述测试可以看出，对中文分词是单个字符进行分组，这显然不是按词语分词，不友好！\n1.4.1 IK分词器处理中文分词一般使用IK分词器（https://github.com/medcl/elasticsearch-analysis-ik），同时github上的一个开源项目，通常采用离线安装方式。\n\n安装插件需要知道ES的plugins目录位置，由于先前用了数据卷挂载，因此可以通过查看ES的数据卷目录，找到本地的插件映射目录：\ndocker volume inspect es-plugins\n\n\n\n上传解压后的分词插件到上述/var/lib/docker/volumes/es-plugins/_data目录下\n\n\n重启ES\ndocker restart es# 查看日志输出docker logs -f es\n\n\n发现版本不匹配，ES是7.16.3，而ik是8.x，因此分词器需要装回7.16.3，再次测试：\n\n测试，IK包含两中分词模式：\n\nik_smart：最少切分\nik_max_word：最细切分\n\n以搜索【Java程序员就业情况】为例，测试结果如下：\n\n可见：ik_max_word细粒度更高，同时耗内存资源也越高，而ik_smart细粒度较低，但耗内存资源也偏低；因此实践中应该根据具体需求进行选择。\n\n\n1.4.2 IK分词器的扩展和停用词典随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，比如”奥利给“，”皇第的新衣“等一些网络词语，而这些词语在现有的词典中并不存在，因此需要扩展；当然也有很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么在搜索时也应该忽略当前词汇。\nIK分词器强大的扩展词典和停用词典功能，如此可以在建索引时就直接补充扩展词典中的内容或者忽略停用词汇表中的内容。\n\n添加IK分词器插件中的 config/KAnalyzer.cfg.xml 配置文件内容如下：\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;&lt;properties&gt;\t&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;\t&lt;!--用户可以在这里配置自己的扩展字典 --&gt;\t&lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;\t &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;\t&lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;\t&lt;!--用户可以在这里配置远程扩展字典 --&gt;\t&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;\t&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;\t&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt;\n\n如上，增加了两个词典：\n\n扩展词典：ext.dic\n停用词典：stopword.dic\n\n同时要在与配置文件同一目录下新建上述两个词典文件，且文件编码必须是UTF-8，里面填写你要扩展或禁止的词语即可：\n\n\n测试如下：\n\n\n\n2. 索引库操作索引就像是关系型数据库中的表。\n2.1 Mapping映射索引\n详细mapping属性请查看：https://www.elastic.co/guide/en/elasticsearch/reference/8.6/mapping-params.html\n\nmapping是对索引库中文档的约束，常见的mapping属性包括：\n\ntype：字段数据类型，常见的简单类型有：\n字符串：text（可分词的文本）、keyword（精确值，不可拆分，例如：国家，奥利给，IP地址）\n数值：long、integer、short、byte、double、float（与Java相似，因为ES底层就是Java实现的）\n布尔：boolean\n日期：date\n对象：object\n\n\nindex：是否创建索引，默认为true（如果为false，那么就不会创建该字段的倒排索引）\nanalyzer：使用那种分词器（结合text一起使用）\nproperties：该字段的子字段\n\n\nES中没有数组类型，但是允许一个字段有多个值\n\n2.2 索引库的CRUD2.2.1 创建索引库ES中通过Restful请求操作索引库、文档。请求内容用DSL语句来表示。创建索引库和mapping的DSL语法如下：\n\n案例：\n\n2.2.2 查看索引库查看索引库语法：\nGET /索引库名称\n\n示例：GET &#x2F;dubulingbo\n&#123;  &quot;dubulingbo&quot; : &#123;    &quot;aliases&quot; : &#123; &#125;,    &quot;mappings&quot; : &#123;      &quot;properties&quot; : &#123;        &quot;email&quot; : &#123;          &quot;type&quot; : &quot;keyword&quot;,          &quot;index&quot; : false        &#125;,        &quot;info&quot; : &#123;          &quot;type&quot; : &quot;text&quot;,          &quot;analyzer&quot; : &quot;ik_smart&quot;        &#125;,        &quot;name&quot; : &#123;          &quot;properties&quot; : &#123;            &quot;firstName&quot; : &#123;              &quot;type&quot; : &quot;keyword&quot;            &#125;,            &quot;lastName&quot; : &#123;              &quot;type&quot; : &quot;keyword&quot;            &#125;          &#125;        &#125;      &#125;    &#125;,    &quot;settings&quot; : &#123;      &quot;index&quot; : &#123;        &quot;routing&quot; : &#123;          &quot;allocation&quot; : &#123;            &quot;include&quot; : &#123;              &quot;_tier_preference&quot; : &quot;data_content&quot;            &#125;          &#125;        &#125;,        &quot;number_of_shards&quot; : &quot;1&quot;,        &quot;provided_name&quot; : &quot;dubulingbo&quot;,        &quot;creation_date&quot; : &quot;1680087689422&quot;,        &quot;number_of_replicas&quot; : &quot;1&quot;,        &quot;uuid&quot; : &quot;v1VM4wJ5S_2LI8AtTxtDQA&quot;,        &quot;version&quot; : &#123;          &quot;created&quot; : &quot;7160399&quot;        &#125;      &#125;    &#125;  &#125;&#125;\n\n\n\n2.2.3 修改索引库一般而言，ES不允许修改索引库，因为会导致建立的倒排索引失效，从而导致查询时，大大降低了性能。但是ES允许添加新的字段，语法如下：\nPUT /索引库名称/_mapping&#123;    &quot;properties&quot;: &#123;        &quot;新字段名&quot;: &#123;            &quot;type&quot;: 字段类型值            ......        &#125;,        ......    &#125;&#125;\n\n示例1：为dubulingbo索引库添加一个age字段，类型为integer\n\n再次查询，已存在age，说明添加成功：\n\n示例2：试图修改 age 字段类型为 long\n\n\n需要注意的是，新添加的字段必须是原来索引库中不存在的字段，否则会报错，即添加失败！\n\n2.2.4 删除索引库DELETE /索引库名称\n\n示例：删除dubulingbo索引库\n\n3. 文档操作文档就是数据，就是向已存在的索引库中增加数据（记录）。常见的文档操作有：新增、修改、查询、删除操作。\n3.1 新增文档DSL语法如下：\nPOST /索引库名/_doc/文档id&#123;    &quot;字段1&quot;: &quot;值1&quot;,    &quot;字段2&quot;: &quot;值2&quot;,    &quot;字段3&quot;: &#123;        &quot;子属性1&quot;: &quot;子属性值1&quot;,        &quot;子属性1&quot;: &quot;子属性值1&quot;,        // ......    &#125;    // ......&#125;\n\n示例：\n\n3.2 查询文档DSL语法：\nGET /索引库名/_doc/要查询的文档id\n\n示例：\n\n不填id测试：\n\n3.3 删除文档DSL语法：\nDELETE /索引库名称/_doc/文档id\n\n\n示例：\n\n\n\n\n若不携带id删除：\n\n\n3.4 修改文档3.4.1 全量修改删除旧文档，添加新文档\n\nDSL语法：\n\nPUT /索引库名/_doc/文档id&#123;    &quot;字段1&quot;: &quot;值1&quot;,    &quot;字段1&quot;: &quot;值1&quot;,    // ......&#125;\n\n\n\n\n示例：\n\n\n修改同一个文档，但是字段值不一样：\n\n再次查询：\n\n值得注意的是：先前的info字段已经被删除，然后新添加的name字段，这就是全量更新！\n3.4.2 增量修改只修改已存在的指定的字段值。\n\nDSL语法为：\n\nPOST /索引库名/_update/文档id&#123;\t&quot;doc&quot;: &#123;        &quot;字段名1&quot;: &quot;字段值1&quot;,        &quot;字段名1&quot;: &quot;字段值1&quot;,        // ......    &#125;&#125;\n\n\n示例：\n\n\n修改不存在的字段 age 为 18：\n\n4. RestClient操作索引库创建、删除、判断索引库是否存在\n4.1 RestClientES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES执行，官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html\n以下以Java客户端的RestClient为例。参考文档：https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html\n\n创建 mapping 需要考虑的问题：\n字段名是什么，数据类型怎么选\n是否参与搜索（决定字段的 index 为 true 还是 false）\n是否分词（决定是 type 是 keyword 还是 text）\n如果分词，分词器怎么选择\n\n\n\nES默认是搜索某个字段的内容，要想同时搜索多个字段内容，可以使用 copy_to 属性:\n示例：\n&quot;all&quot;: &#123;    &quot;type&quot;: &quot;text&quot;,    &quot;analyzer&quot;: &quot;ik_max_word&quot;&#125;&quot;brand&quot;: &#123;    &quot;type&quot;: &quot;keyword&quot;,    &quot;copy_to&quot;: &quot;all&quot; // 表示将当前字段的值拷贝到 all 字段，如此，直接搜索all字段就能解决&#125;\n\n\n\n\n案例：将hotel表转化成mapping\n\n\n转成 mapping 如下：\n// 创建酒店的mappingPUT /hotel&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;id&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_max_word&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;address&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;price&quot;: &#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;score&quot;: &#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;brand&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;city&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;starName&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;business&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;location&quot;: &#123;        &quot;type&quot;: &quot;geo_point&quot;  // 地理坐标点      &#125;,      &quot;pic&quot;: &#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;all&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_max_word&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n4.2 初始化 JavaRestClient\n引入ES的RestHighLevelClient依赖：\n\n&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;    &lt;version&gt;$&#123;elasticsearch.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n\n\n因为SpringBoot默认的ES版本是7.6.2，所以要换成之前安装的ES版本7.16.3：\n\n&lt;properties&gt;    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;!-- 修改默认的 Spring Boot 中 elasticsearch 的版本，默认是 7.6.2 --&gt;    &lt;elasticsearch.version&gt;7.16.3&lt;/elasticsearch.version&gt;&lt;/properties&gt;\n\n\n\n初始化RestHighLevelClient：\n\nRestHighLevelClient client = new RestHighLevelClient(RestClient.builder(\t\tHttpHost.create(&quot;http://你的虚拟机ip:9200&quot;)));\n\n\n\n4.3 JavaRestClient 操作索引库对索引库操作代码模版示意：\n\n代码如下：（包含创建、删除、判断是否存在）\nimport org.apache.http.HttpHost;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.CreateIndexRequest;import org.elasticsearch.xcontent.XContentType;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;// 创建索引的json模版import static com.dublbo.hotel.constants.HotelConstant.MAPPING_TEMPLATE;/** * @author dubulingbo, 2023/3/29 22:09. */public class HotelIndexTest &#123;    private RestHighLevelClient client;    @BeforeEach    void setUp() &#123;        this.client = new RestHighLevelClient(RestClient.builder(                HttpHost.create(&quot;http://10.255.125.164:9200&quot;)        ));    &#125;    @Test    void createHotelIndex() throws IOException &#123;        // 1. 创建Request的对象        CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;);        // 2. 准备请求参数：DSL语句        request.source(MAPPING_TEMPLATE, XContentType.JSON);        // 3. 发送请求，默认就是 PUT 请求        client.indices().create(request, RequestOptions.DEFAULT);    &#125;            @Test    void deleteHotelIndex() throws IOException &#123;        // 1. 创建Request的对象        DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;);        // 2. 发送删除请求        client.indices().delete(request, RequestOptions.DEFAULT);    &#125;    @Test    void existsHotelIndex() throws IOException &#123;        // 1. 创建Request的对象        GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;);        // 2. 判断是否存在        boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);        System.out.println(exists ? &quot;hotel索引库存在&quot; : &quot;hotel索引库不存在&quot;);    &#125;    @AfterEach    void tearDown() throws IOException &#123;        this.client.close();    &#125;&#125;\n\n\n\n4.4 JavaRestClient 操作文档案例：从数据库中导入hotel表到索引库，实现对hotel索引库的文档的CRUD\n\n初始化JavaRestClient\n\n\n\n利用JavaRestClient新增酒店数据\n利用JavaRestClient根据id查询酒店数据\n利用JavaRestClient删除酒店数据\n修改JavaRestClient酒店数据\n\n代码如下：\nimport com.alibaba.fastjson.JSON;import com.dublbo.hotel.pojo.Hotel;import com.dublbo.hotel.pojo.HotelDocument;import com.dublbo.hotel.service.IHotelService;import org.apache.http.HttpHost;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.xcontent.XContentType;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;import java.io.IOException;/** * @author dubulingbo, 2023/3/30 11:08. */@SpringBootTestpublic class HotelDocumentTest &#123;    private RestHighLevelClient client;    @Resource    private IHotelService hotelService;    // 初始化    @BeforeEach    void setUp() &#123;        this.client = new RestHighLevelClient(RestClient.builder(                HttpHost.create(&quot;http://10.255.125.164:9200&quot;)        ));    &#125;    // 新增文档    @Test    void testAddDocument() throws IOException &#123;        // 根据id查询酒店数据        Hotel hotel = hotelService.getById(395702L);        // 转化为文档类型        HotelDocument document = new HotelDocument(hotel);        // 1. 准备Request对象        IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(document.getId().toString());        // 2. 准备Json文档        request.source(JSON.toJSONString(document), XContentType.JSON);        // 3. 发送请求        client.index(request, RequestOptions.DEFAULT);    &#125;    // 查询文档，根据id    @Test    void testGetDocumentById() throws IOException &#123;        GetRequest request = new GetRequest(&quot;hotel&quot;, &quot;395702&quot;);        GetResponse response = client.get(request, RequestOptions.DEFAULT);        // 解析响应结果        String json = response.getSourceAsString();        HotelDocument doc = JSON.parseObject(json, HotelDocument.class);        System.out.println(doc);    &#125;    // 局部更新，（全量更新和添加一样）    @Test    void testUpdateDocument() throws IOException &#123;        UpdateRequest request = new UpdateRequest(&quot;hotel&quot;, &quot;395702&quot;);        request.doc(                &quot;price&quot;, &quot;-18&quot;,  //直接逗号隔开， key -&gt; value                &quot;starName&quot;, &quot;啥也不是&quot;        );        UpdateResponse response = client.update(request, RequestOptions.DEFAULT);        System.out.println(response);    &#125;    // 删除文档    @Test    void testDeleteDocumentById() throws IOException &#123;        DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, &quot;395702&quot;);        DeleteResponse r = client.delete(request, RequestOptions.DEFAULT);        System.out.println(r);    &#125;    // 释放对象    @AfterEach    void tearDown() throws IOException &#123;        this.client.close();    &#125;&#125;\n\n\n\n\n批量导入文档\n\n@Testvoid testBatchAddDocument() throws IOException &#123;    List&lt;Hotel&gt; list = hotelService.list(Wrappers.&lt;Hotel&gt;query().like(&quot;city&quot;, &quot;上海&quot;));    System.out.println(&quot;待新增文档数为：&quot; + list.size());    // 1. 创建Request    BulkRequest request = new BulkRequest();    // 2. 添加多个新增的Request    for (Hotel hotel : list) &#123;        HotelDocument doc = new HotelDocument(hotel);        request.add(            new IndexRequest(&quot;hotel&quot;)            .id(doc.getId().toString())            .source(JSON.toJSONString(doc), XContentType.JSON)        );    &#125;    // 3. 发送请求    client.bulk(request, RequestOptions.DEFAULT);&#125;\n\n测试：\n\n\n共插入83条文档，与mysql查询的数据量一致，导入成功！\n5. 待完成事项\n ES搜索功能，包括语法、API学习\n\n","categories":["Java"],"tags":["Elastic Search"]},{"title":"Message Queue初体验","url":"/java/mq-base/","content":"\nMessage Queue和RabbitMQ的入门学习，即部署与简单使用；\nSpringAMQP的api学习\n\n\n\n初识MQ1. 同步调用方案响应耗时长，服务耦合度较高，不便于维护\n2. 异步调用方案异步调用方案实现就是事件驱动模式\n\n\n优势：\n服务解耦\n性能提升，吞吐量增加\n服务没有强依赖，不用担心级联失败问题\n流量削峰\n\n\n缺点：\n依赖于Broker的可靠性、安全性、吞吐能力\n架构复杂了，业务没有明显的流程线，不便于追踪管理\n\n\n\n3. 什么是MQMQ（Message Queue），消息队列，用来存放消息的队列，也就是事件驱动架构中的Broker。\n\n\n\n\nRabbitMQ\nActiveMQ\nRocketMQ\nKafaka\n\n\n\n公司&#x2F;社区\nRabbit\nApache\n阿里\nApache\n\n\n开发语言\nErlang\nJava\nJava\nScala、Java\n\n\n协议支持\nAMQP、XMPP、SMTP、STOMP\nOpenWire、STOMP、REST、XMPP、AMQP\n自定义协议\n自定义协议\n\n\n可用性\n高\n一般\n高\n高\n\n\n单机吞吐量\n一般\n差\n高\n非常高\n\n\n消息延迟\n微秒级\n毫秒级\n毫秒级\n毫秒内\n\n\n消息可靠性\n高\n一般\n高\n一般\n\n\n4. RabbitMQ 快速入门\nhttps://www.rabbitmq.com/\n\n\n推荐 docker 进行安装\ndocker pull rabbitmq\n\n运行\ndocker run \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=admin \\ --name rbmq \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management\n\n其中：\n\n-p 15672:15672 设置的是管理界面的端口\n-p 5672:5672 设置的是消息通信的端口\n\n\n如果不能打开管理页面，可能需要激活管理插件：\n\ndocker exec -it rbmq bash\nrabbitmq-plugins enable rabbitmq_management\n\n\n\n4.1 结构\n\n几个概念\nchannel：操作MQ的工具\nexchange：路由消息到队列中\nqueue：缓存消息\nvirtual host：虚拟主机，是对queue、exchange等资源的逻辑分组\n\n\n\n4.2 常见消息模型官网给出了5种消息模型，对应了几种不同的用法：\n\n基本消息队列\n工作消息队列\n\n\n\n发布订阅，根据交换机类型不同，分为三种：\n\n广播：Fanout Exchange\n路由：Direct Exchange\n主题：Topic Exchange\n\n\n\n\n4.2.1 HelloWorld案例 - 简单模型官方的Helloworld是基于最基础的消息队列模型实现的，只包括三个角色：\n\npublisher：消息的发布者，将消息发送到队列queue\nqueue：消息队列，负责接收并缓存消息\nconsumer：订阅队列，处理队列中的消息\n\n\n\n消息发送流程：\n\n\n建立connection\n创建channel\n利用channel声明队列\n利用channel向队列发送消息\n\n\n消息接收（消费）流程：\n\n\n建立connection\n创建channel\n利用channel声明队列\n定义consumer的消费行为 handleDelivery() 回调函数\n利用channel将消费者与队列绑定\n\n\n具体代码实现如下：\n\n\nPublisher：\n@Testpublic void testSendMessage() throws IOException, TimeoutException &#123;    // 1.建立连接    ConnectionFactory factory = new ConnectionFactory();    // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码    factory.setHost(&quot;10.255.125.164&quot;);    factory.setPort(5672);    factory.setVirtualHost(&quot;/&quot;);    factory.setUsername(&quot;admin&quot;);    factory.setPassword(&quot;admin&quot;);    // 1.2.建立连接    Connection connection = factory.newConnection();    // 2.创建通道Channel    Channel channel = connection.createChannel();    // 3.创建队列    String queueName = &quot;first.queue&quot;;    channel.queueDeclare(queueName, false, false, false, null);    // 4.发送消息    String message = &quot;Hello, RabbitMQ!&quot;;    channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());    System.out.printf(&quot;发送消息成功 -&gt; %s%n&quot;, message);    // 5.关闭通道和连接    channel.close();    connection.close();&#125;\n\n\n测试运行：\n\n\n\n\nConsumer:\n@Testpublic void testHandleMessage() throws IOException, TimeoutException &#123;    // 1. 建立连接    ConnectionFactory factory = new ConnectionFactory();    // 1.1 设置连接参数，分别是：主机名、端口号、virtual host、用户名、密码    factory.setHost(&quot;10.255.125.164&quot;);    factory.setPort(5672);    factory.setVirtualHost(&quot;/&quot;);    factory.setUsername(&quot;admin&quot;);    factory.setPassword(&quot;admin&quot;);    // 1.2 建立连接    Connection conn = factory.newConnection();    // 2. 创建通道 channel    Channel channel = conn.createChannel();    // 3. 创建消息队列    String queName = &quot;first.queue&quot;;    channel.queueDeclare(queName, false, false, false, null);    // 4. 订阅消息    channel.basicConsume(queName, true, new DefaultConsumer(channel) &#123;        @Override        public void handleDelivery(String consumerTag,                                   Envelope envelope,                                   AMQP.BasicProperties properties,                                   byte[] body) throws IOException &#123;            // 5. 实现处理消息的行为            String message = new String(body);            System.out.printf(&quot;接收到的消息 -&gt; %s%n&quot;, message);        &#125;    &#125;);    System.out.println(&quot;等待接收消息......&quot;);&#125;\n\n\n测试结果：\n\n\n\n\n\n\n4.2.2 引入SpringAMQP什么是SpringAMQP\n官方介绍：https://spring.io/projects/spring-amqp\n\nAMQP(Advanced Message Queue Protocol)是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。\n而 SpringAMQP 是基于 AMQP 协议的一套API规范，提供了发送和接收处理消息的模板。包含两部分，其中spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现。\n改写Helloword案例：\n发布消息\n引入依赖\n\n&lt;!-- spring amqp依赖，包含了rabbit mq --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n配置 mq 信息：\n\nspring:  rabbitmq:    host: 10.255.125.164 # rabbitMQ的ip地址    port: 5672 # 端口    username: admin    password: admin    virtual-host: /\n\n\n测试：\n\nimport org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;/** * @author dubulingbo, 2023/3/27 19:57. */@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringAMQPTest &#123;    @Resource    RabbitTemplate rabbitTemplate;    @Test    public void testSend() &#123;        String queName = &quot;first.queue&quot;;        String msg = &quot;Hellooooo, spring amqp!&quot;;        rabbitTemplate.convertAndSend(queName, msg);    &#125;&#125;\n\n\n结果：\n\n\n接收消息&#x2F;处理消息前两步与发布消息相同，这里不在赘述！\n\n实现：\n\n// 定义RabbitListener@Componentpublic class RabbitMQListener &#123;    @RabbitListener(queues = &#123;&quot;first.queue&quot;&#125;)    public void listenFirstQueue(String msg) &#123;        System.out.printf(&quot;消费者收到first.queue的消息 -&gt; %s%n&quot;, msg);    &#125;&#125;// 主启动类@SpringBootApplicationpublic class ConsumerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConsumerApplication.class, args);    &#125;&#125;\n\n\n结果：\n\n\n4.2.3 Work queues案例 - 工作队列模型\n\n消费者：\n\npublic class RabbitMQListener &#123;    @RabbitListener(queues = &#123;&quot;first.queue&quot;&#125;)    public void listenFirstQueue1(String msg) throws InterruptedException &#123;        System.out.printf(&quot;消费者 1 收到first.queue的消息 -&gt; [%s] %s%n&quot;, msg, LocalTime.now());        Thread.sleep(20);    &#125;    @RabbitListener(queues = &#123;&quot;first.queue&quot;&#125;)    public void listenFirstQueue2(String msg) throws InterruptedException &#123;        System.err.printf(&quot;消费者 2 收到first.queue的消息 -&gt; [%s] %s%n&quot;, msg, LocalTime.now());        Thread.sleep(200);    &#125;&#125;\n\n\n发布者模拟发送10条消息：\n\n@Testpublic void testSendMessage2WorkQueue() throws InterruptedException &#123;    String queName = &quot;first.queue&quot;;    String msg = &quot;Hello, message - &quot;;    for (int i = 0; i &lt; 50; ++i) &#123;        rabbitTemplate.convertAndSend(queName, msg + (i + 1));        Thread.sleep(20);    &#125;&#125;\n\n\n测试结果：\n\n\n有上述结果可看出，并没有实现“能者多劳”的现象，而是均等分配了消息，其原因是SpringAMQP默认消费者是均等预取的，即相当于 在消费前就将消息均等分配到每个消费者，而不管其执行时间的长短 ；因此设置预取数量，即增加消费者配置项如下：\nspring:  rabbitmq:    ......    listener:      simple:        prefetch: 1 # 每次最多取一条消息，消费完再取下一条\n\n再次运行，结果如下：\n\n4.2.4 发布、订阅模型发布订阅模型与之前的模型区别就是允许同一个消息发送给多个消费者。实现方式是加入了 Exchange（交换机）。常见的exchange有以下三种：\n\nFanout：广播\nDirect：路由\nTopic：话题\n\n注意：exchange只负责消息路由，而不是存储，路由失败则消息丢失。\n4.2.4.1 Fanout - 广播Fanout Exchange 会将接收到的消息路由到每一个与其绑定的queue\n\n\nP - Publisher\nX - Exchange\nC - Consumer\n\n\n实现思路：\n在consumer服务中，声明队列，交换机、并将两者绑定\n在consumer服务中，编写两个消费者consumer1、consumer2方法，分别监听fanout.queue1和fanout.queue2\n在publisher中编写测试方法，向交换机fanout.exchange发消息\n\n\n\nSpringAMQP提供了声明交换机、队列的绑定关系API如下：\n\n具体实现如：\nimport org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author dubulingbo, 2023/3/27 23:27. */@Configurationpublic class FanoutConfig &#123;    // 声明交换机 fanout.exchange    @Bean    public FanoutExchange fanoutExchange() &#123;        return new FanoutExchange(&quot;fanout.exchange&quot;);    &#125;    // 声明 fanout.queue1    @Bean    public Queue fanoutQueue1() &#123;        return new Queue(&quot;fanout.queue1&quot;);    &#125;    // 声明 fanout.queue2    @Bean    public Queue fanoutQueue2() &#123;        return new Queue(&quot;fanout.queue2&quot;);    &#125;    // 绑定fanout.queue1到交换机    // 变量名必须一致，否则绑定会失败    @Bean    public Binding fanoutBinding1(Queue fanoutQueue1, FanoutExchange fanoutExchange) &#123;        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);    &#125;    // 绑定fanout.queue2到交换机    @Bean    public Binding fanoutBinding2(Queue fanoutQueue2, FanoutExchange fanoutExchange) &#123;        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);    &#125;&#125;\n\n运行后，进入RabbitMQ后台界面，绑定结果如下：\n\n消费者消息监听：\n@Componentpublic class RabbitMQListener &#123;    @RabbitListener(queues = &#123;&quot;fanout.queue1&quot;&#125;)    public void listenFanoutQueue1(String msg) &#123;        System.err.printf(&quot;消费者接收到fanout.queue1的消息 -&gt; [%s]%n&quot;, msg);    &#125;    @RabbitListener(queues = &#123;&quot;fanout.queue2&quot;&#125;)    public void listenFanoutQueue2(String msg) &#123;        System.err.printf(&quot;消费者接收到fanout.queue2的消息 -&gt; [%s]%n&quot;, msg);    &#125;&#125;\n\n发布者发布消息：\n@Testpublic void testSendFanoutExchange() &#123;    // 交换机名称    String ex = &quot;fanout.exchange&quot;;    // 消息    String msg = &quot;Hello, every one!&quot;;    // 发送消息    rabbitTemplate.convertAndSend(ex, &quot;&quot;, msg);&#125;\n\n测试结果：\n\n\n小结：\n交换机的作用：\n\n接收publisher发送的消息\n将消息按照规则路由到与之绑定的队列\n不能缓存消息、路由失败，消息丢失\nFanoutExchange会将消息路由到每一个绑定的队列\n\n声明交换机、队列、绑定关系的Bean：\n\norg.springframework.amqp.core.FanoutExchange\norg.springframework.amqp.core.Queue\norg.springframework.amqp.core.Binding\norg.springframework.amqp.core.BindingBuilder::bind(queue)::to(exchange)\n\n\n\n\n4.2.4.2 Direct - 路由Direct Exchange 会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）。\n\n每一个Queue都与Exchange设置一个 Binding Key\n发布者发送消息时，指定消息的 Routing Key\nExchange将消息路由到Binding Key 和 Routing Key 一致的队列\n\n\n实现：\n\n消费者（注解实现）\n\n@Componentpublic class RabbitMQListener &#123;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(name = &quot;direct.queue1&quot;),            exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),            key = &quot;error&quot;    ))    public void listenDirectQueue1(String msg) &#123;        System.out.printf(&quot;消费者接收到direct.queue1的消息 -&gt; %s%n&quot;, msg);    &#125;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(name = &quot;direct.queue2&quot;),            exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT),            key = &#123;&quot;info&quot;, &quot;error&quot;, &quot;warning&quot;&#125;    ))    public void listenDirectQueue2(String msg) &#123;        System.out.printf(&quot;消费者接收到direct.queue2的消息 -&gt; %s%n&quot;, msg);    &#125;&#125;\n\n运行后，进入RabbitMQ后台界面，绑定结果如下：\n\n发布者发布消息：\n@Testpublic void testSendDirectExchange() &#123;    // 交换机名称    String ex = &quot;direct.exchange&quot;;    // 发送消息    rabbitTemplate.convertAndSend(ex, &quot;info&quot;, &quot;This is info message&quot;);    rabbitTemplate.convertAndSend(ex, &quot;error&quot;, &quot;This is error message&quot;);    rabbitTemplate.convertAndSend(ex, &quot;warning&quot;, &quot;This is warning message&quot;);    // 这条消息会被丢弃，因为找不到匹配的队列    rabbitTemplate.convertAndSend(ex, &quot;success&quot;, &quot;This is success message&quot;);&#125;\n\n运行结果：\n\n4.2.4.3 Topic - 话题TopicExchange与DirectExchange类似，区别在于routing key必须是多个单词的列表，并且以.分割。Queue与Exchange指定Binding Key时，可以使用通配符：\n\n‘#’：代表0个或多个单词\n‘*’：代指一个单词\n\n\n实现：\n\n消费者：\n\n@Componentpublic class RabbitMQListener &#123;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(&quot;topic.queue1&quot;),            exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC),            key = &quot;*.orange.*&quot;    ))    public void listenTopicQueue1(String msg) &#123;        System.err.printf(&quot;消费者接收到topic.queue1的消息 -&gt; %s%n&quot;, msg);    &#125;    @RabbitListener(bindings = @QueueBinding(            value = @Queue(&quot;topic.queue2&quot;),            exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC),            key = &#123;&quot;*.*.rabbit&quot;, &quot;lazy.#&quot;&#125;    ))    public void listenTopicQueue2(String msg) &#123;        System.out.printf(&quot;消费者接收到topic.queue2的消息 -&gt; %s%n&quot;, msg);    &#125;&#125;\n\n运行后，进入RabbitMQ后台界面，绑定结果如下：\n\n\n发布者发布如下消息：\n\n@Testpublic void testSendTopicExchange() &#123;    // 交换机名称    String ex = &quot;topic.exchange&quot;;    // 发送消息    rabbitTemplate.convertAndSend(ex, &quot;1.orange&quot;, &quot;1.orange&quot;);    rabbitTemplate.convertAndSend(ex, &quot;1.orange.2&quot;, &quot;1.orange.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;orange.2&quot;, &quot;orange.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;orange.rabbit&quot;, &quot;orange.rabbit&quot;);    rabbitTemplate.convertAndSend(ex, &quot;.rabbit&quot;, &quot;.rabbit&quot;);    rabbitTemplate.convertAndSend(ex, &quot;.rabbit.&quot;, &quot;.rabbit.&quot;);    rabbitTemplate.convertAndSend(ex, &quot;..rabbit&quot;, &quot;..rabbit&quot;);    rabbitTemplate.convertAndSend(ex, &quot;.orange.&quot;, &quot;.orange.&quot;);    rabbitTemplate.convertAndSend(ex, &quot;rabbit.2&quot;, &quot;rabbit.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;orange.rabbit.2&quot;, &quot;orange.rabbit.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;orange.orange.rabbit.2&quot;, &quot;orange.orange.rabbit.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;orange.orange.rabbit&quot;, &quot;orange.orange.rabbit&quot;);    rabbitTemplate.convertAndSend(ex, &quot;1.2.3.rabbit&quot;, &quot;1.2.3.rabbit&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy.&quot;, &quot;lazy.&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy.1&quot;, &quot;lazy.1&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy.123&quot;, &quot;lazy.123&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy.1.2&quot;, &quot;lazy.1.2&quot;);    rabbitTemplate.convertAndSend(ex, &quot;.lazy&quot;, &quot;.lazy&quot;);    rabbitTemplate.convertAndSend(ex, &quot;.lazy.&quot;, &quot;.lazy.&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy#123&quot;, &quot;lazy#123&quot;);    rabbitTemplate.convertAndSend(ex, &quot;lazy.123.&quot;, &quot;lazy.123.&quot;);&#125;\n\n\n\n运行结果如下：\n\n\n4.3 消息转换器在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说可以发送任意对象数据类型的消息，SpringAMQP会将其序列化为字节进行发送。\n\n默认使用实现序列化\n\n发送的消息为：\n@Testpublic void testSendObjectQueue() &#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;, &quot;dubulingbo&quot;);    map.put(&quot;age&quot;, 26);    rabbitTemplate.convertAndSend(&quot;object.queue&quot;, map);&#125;\n\n\n\n引入 jackson 序列化：\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n配置MessageConverter\n@Beanpublic MessageConverter messageConverter() &#123;    return new Jackson2JsonMessageConverter();&#125;\n\n\n\n\n\n接收消息：\n// 直接用 Map 接收，SpringAMQP 会自动完成反序列化@RabbitListener(queues = &quot;object.queue&quot;)public void listenObjectQueue(Map&lt;String, Object&gt; msg) &#123;    System.out.printf(&quot;消费者接收到object.queue的消息 -&gt; %s%n&quot;, msg);&#125;\n\n测试：\n\n\n\nSpringAMQP中消息的序列化和反序列化是怎么实现的？\n\n利用MessageConverter实现，默认是JDK的序列化\n注意发送方与接收方必须使用相同的MessageConverter\n\n4.4 写在最后队列中的消息一旦消费就会从队列中删除，RabbitMQ没有消息回溯功能！\n","categories":["Java"],"tags":["Java","RabbitMQ","SpringAMQP"]},{"title":"快捷键 - 搜集比较常用的快捷键","url":"/efficiency-work/popular-keyboard/","content":"一、Windows 10 快捷键\n\n\n快捷键\n说明\n\n\n\nWindows\n打开开始菜单栏\n\n\nWindows + U\n打开设置\n\n\nWindows + D\n回到桌面\n\n\nWindows + Tab\n桌面切换\n\n\nWindows + R\n打开命令窗口（CMD）\n\n\nWindows + E\n打开文件资源管理器\n\n\nWindows + S\n全局搜索\n\n\nWindows + A\n打开右侧多任务侧边栏\n\n\nWindows + L\n锁屏\n\n\nWindows + V\n打开剪贴板历史记录\n\n\nWindows + “+&#x2F;-“\n放大&#x2F;缩小屏幕\n\n\nWindows + Ctrl + “←&#x2F;→”\n快速切换虚拟桌面\n\n\n\n\n\n\nAlt + Tab\n窗口切换\n\n\n二、Chrome 快捷键 — Windows\n\n\n快捷键\n操作描述\n\n\n\nCtrl + n\n打开新窗口\n\n\nCtrl + Shift + n\n以隐身模式打开新窗口\n\n\nCtrl + t\n打开新的标签页，并切换到该标签页\n\n\nCtrl + Tab\n切换到下一个标签页（向右平移一个）\n\n\nCtrl + Shift + Tab\n切换到上一个标签页（向左平移一个）\n\n\nCtrl + 1 到 Ctrl + 8\n切换到指定标签页\n\n\nCtrl + 9\n切换到最后一个标签页（最右边一个）\n\n\nCtrl + w\n关闭当前标签页\n\n\nCtrl + f\n在当前页面进行内容搜索\n\n\nCtrl + Shift + w &#x2F; Alt + F4\n关闭所有标签页和浏览器\n\n\n\n\n\n\nCtrl + h\n在新标签页中打开 “历史记录”\n\n\nCtrl + j\n在新标签页中打开“下载内容”\n\n\nCtrl + Shift + Del\n在新标签页中打开 “清除浏览数据” 弹窗\n\n\nCtrl + Shift + b\n显示或隐藏书签栏\n\n\nCtrl + Shift + o\n在新标签页中打开 “书签管理页面”\n\n\nAlt + Home\n在当前标签页中打开 “主页”\n\n\nAlt + d | F6\n在当前标签页，跳转到地址栏\n\n\n\n\n\n\nCtrl + R\n重新加载当前网页，相当于按下 “刷新“ 按钮\n\n\nCtrl + Shift + R\n重新加载当前网页（忽略缓存的内容）\n\n\nCtrl + U\n在新标签页中查看此页面源码\n\n\nCtrl + D\n将当前网页保存为书签\n\n\nF11\n开启或关闭全屏模式\n\n\n\n\n\n\nCtrl + +\n放大网页上的所有内容\n\n\nCtrl + 0\n将网页上的所有内容恢复到默认大小\n\n\nCtrl + -\n缩小网页上的所有内容\n\n\n三、IDEA 快捷键 — Windows\n\n\n快捷键\n说明\n\n\n\nCtrl + D\n复制光标所在行或已选择的部分\n\n\nCtrl + Y\n删除一行\n\n\nCtrl + Z\n撤销\n\n\nShift + F6\n重命名（文件名、类名、变量名）\n\n\nCtrl + Ctrl\n全局搜索类\n\n\nCtrl + F\n当前文件中搜索\n\n\nCtrl + R\n当前文件中替换\n\n\n\n\n\n\nCtrl + Shift + U\n全部转换成大写字母\n\n\nCtrl + Shift + L\n全部转换成小写字母\n\n\n四、VsCode快捷键\n\n\n快捷键\n描述\n\n\n\nCtrl + X\n剪切一行或选择的\n\n\nCtrl + C\n复制一行或选择的\n\n\nAlt + ↑&#x2F;↓\n把光标所在行上移&#x2F;下移\n\n\nShift + Alt + ↑&#x2F;↓\n把光标所在行往上&#x2F;下复制一行\n\n\n\n\n\n\nCtrl + B\n显示或隐藏侧边栏\n\n\n五、Visio快捷键\n\n\n快捷键\n描述\n\n\n\nctrl + shift + P\n格式刷\n\n\nCtrl + 1\n指针工具\n\n\nCtrl + 2\n文本工具\n\n\nCtrl + 3\n连接线工具\n\n\nCtrl + 4\n铅笔工具\n\n\nCtrl + 5\n自由绘制工具\n\n\nCtrl + 6\n线条工具\n\n\nCtrl + 7\n弧形工具\n\n\nCtrl + 8\n矩形工具\n\n\nCtrl + 9\n椭圆形工具\n\n\nCtrl + Shift + 1\n连接点工具\n\n\nCtrl + Shift + 2\n连接点工具\n\n\nCtrl + Shift + 3\n印章工具\n\n\nCtrl + Shift + 4\n文本框工具\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n水平&#x2F;垂直快速复制图形\n\n\n\n水平&#x2F;垂直移动图形\n\n\nShift + 方向键\n微移图形\n\n\n方向键\n移动图形\n\n\n\n\n\n\nCtrl + G | Ctrl + Shift + G\n组合\n\n\nCtrl + Shift + U\n取消组合\n\n\nCtrl + J\n垂直翻转\n\n\nCtrl + H\n水平翻转\n\n\nCtrl + R\n右旋转\n\n\nCtrl + L\n左旋转\n\n\nCtrl + Shift + F\n置顶\n\n\nCtrl + Shift + B\n置底\n\n\nCtrl + K\n添加超链接\n\n\nCtrl + 鼠标左键单击\n打开超链接\n\n\nShift + F10\n弹出鼠标右键功能表\n\n\nCtrl + C\n复制\n\n\nCtrl + V\n粘贴\n\n\nCtrl + X\n剪切\n\n\nCtrl + A\n全选图形\n\n\nCtrl + Z\n撤销\n\n\nCtrl + Y | F4\n重复上一步操作\n\n\nCtrl + S\n保存\n\n\nF12 | Alt + F2\n另存为\n\n\nCtrl + O | Ctrl + Alt + F2\n打开本地文件\n\n\n\n\n\n\nCtrl + Shift + C\n水平居中文本\n\n\nCtrl + Shift + L\n左对齐文本\n\n\nCtrl + Shift + R\n右对齐文本\n\n\nCtrl + Shift + J\n两端对齐文本\n\n\nCtrl + Shift + M\n垂直居中文本\n\n\nCtrl + Shift + V\n底端对齐文本\n\n\nCtrl + Shift + T\n顶端对齐文本\n\n\nCtrl + Delete\n删除本段光标之后的内容\n\n\nCtrl + Backspace（退格键）\n删除本段光标之前的内容\n\n\nCtrl + B\n加粗\n\n\nCtrl + U\n下划线\n\n\nCtrl + I\n斜体\n\n\nCtrl + &#x3D;\n下标\n\n\nCtrl + Shift + &#x3D;\n上标\n\n\nCtrl + Shift + D\n双下划线\n\n\nCtrl + Shift + 《\n缩小字号\n\n\nCtrl + Shift + 》\n增大字号\n\n\nCtrl + M | Enter\n换行\n\n\n\n\n\n\nF2\n切换文本编辑模式\n\n\nCtrl + F9\n插入域\n\n\nCtrl + E\n输入域-形状高度\n\n\nCtrl + F\n查找文本\n\n\nCtrl + T Ctrl&#x2F;Shift + Q\n清除文本\n\n\nCtrl + Shift + A\n全部大写\n\n\nCtrl + Shift + K\n小型大写字母\n\n\nCtrl + N\n新建文件\n\n\nCtrl + P Ctrl + F2 Ctrl + Shift + F12\n打印文件\n\n\nCtrl + F4 Alt + F4 Ctrl + Shift + F4 Ctrl + W\n关闭文件\n\n\nCtrl + 鼠标滚轮\n上滚：放大视图下滚：缩小视图\n\n\nShift + 鼠标滚轮\n上滚：左移视图下滚：右移视图\n\n\n鼠标滚轮\n上下移动视图\n\n\nCtrl + Shift + W\n将视图调整到窗口大小\n\n\nCtrl + Alt + 鼠标右键单击 Alt + Shift + F6\n缩小画面\n\n\nAlt + F6\n放大画面\n\n\nCtrl + Alt + 鼠标左键框选\n放大选中的画面部分\n\n\nCtrl + Alt + 鼠标右键拖动\n拖动画面移动\n\n\nShift + F11\n新建页\n\n\nCtrl + Shift + F7 Ctrl + F5\n以水平平铺方式显示打开绘图窗口\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n六、Mac快捷键\nCommand 键\nOption 键\n图标键\nCtrl 键\n\n七、Mac必装软件\nTencent Lemon 垃圾清理软件\nAirServer 投屏软件\neZip 解压工具\nXnip 滚动截图（截长图）\nFliqlo 屏保时钟\nVscode\nAndroid Studio IDE\nTypora Markdown文本写作工具\nNavicat 数据库管理\nAlfred 搜索神器\n\n","categories":["效率办公"],"tags":["快捷键"]},{"title":"视频测试","url":"/personal-summary/hello-world/","content":"图片\n\n\n","categories":["个人总结"]},{"title":"hexo安装和主题美化","url":"/hexo-build-and-theme-beautify/install-beautify/","content":"我是摘要\n\n\n1. 安装1.1 环境准备\nnode环境 - 16.x\n\n\n\nhexo安装\n# 全局安装npm install -g hexo-cli\n\n\n配置hexo环境变量，将node_module目录加入path变量\n\n创建博客\nhexo init [博客项目名称]cd [博客项目名称]npm install\n\n1.2 hexo博客项目文件说明\n_config.yml ：网站配置文件，用于设置站点信息，URL，部署，构建信息等\n_config.theme名.yml ：主题配置文件，用于定制化个人主题\nsource ：源码文件夹\n_data ：存放定制主题时相关静态资源\n_post ：存放文章与草稿，markdown文件\n\n\ntheme ：主题文件夹，将需要更换的主题放入该目录下即可\ndb.json ：记录生成站点网页所需的数据\npublic ：静态网页站点生成目录，部署时也是将该目录下的所有文件拷贝的网站根目录下\n\n\n2. 美化博客这里选用[hexo-theme-shoka](https://gitee.com/KINGWDY_admin/hexo-theme-shoka.git)主题来进行美化，也可去[主题库](https://hexo.io/themes/)选用自己心仪的主题\n\n\n将shoka主题copy到theme文件夹下：\ngit clone https://gitee.com/KINGWDY_admin/hexo-theme-shoka.git ./theme/shoka\n\n将默认主题 landscape 去掉，卸载：\nnpm uninstall hexo-theme-landscape --save\n\n\n安装具体插件请参照教程，这里不再赘述，下面主要记录自己在shoka主题上的一些定制化修改\n\n2.1 修改主要色调\nshoka主题原生使用的 –-color-orange 和 --color-pink 两种颜色的渐变色，将 theme/shoka/source/css 下所有文件出现这两个颜色的地方修改成自己的颜色即可\n\nsidebar\n\n\n顶部导航栏nav的色调为 --nav-bg\n\n点击鼠标的火花颜色在 theme/shoka/_config.yml 中 fireworks 配置\n\n\n参考资料\n官网教程：https://hexo.io/zh-cn/docs/\nshaka 主题教程：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/\n\n","categories":["Hexo博客搭建及主题美化"],"tags":["Hexo","教程"]},{"title":"Hexo博客部署，发布到Github Pages","url":"/hexo-build-and-theme-beautify/push-deploy/","content":"\n\n\n缘起鉴于共享学习与开放交流精神，将个人博客开放到外网。（看上去有点zhuang）其实真是原因就是1：租服务器成本太高；2：还得买域名和搭建环境，太麻烦，不太适合初学者（后续考虑迁移到自己云服务器）。\n构建hexo博客页面\n关于如何搭建hexo环境写博客，请参考hexo博客搭建教程\n\n进入博客根目录，执行下述命令\n\nhexo clean ：清理原来的构建痕迹，已便重新构建\nhexo generate | hexo g ：生产静态页面，默认会在 &lt;root&gt;/public 目录下\nhexo deploy ：部署网站\n\n发布到GitHub Pages\n官网教程：https://docs.github.com/en/pages\n\n新建Git repository\n仓库的名称&#x3D;&#x3D;一定&#x3D;&#x3D;要是 github账号.github.io①，且为 public\n\n在 &#x2F;_config.yml 中添加如下配置：\n# 文章路径配置，否则不能通过链接访问url: https://dubulingbo.github.ioroot: /# 部署服务器配置deploy:  type: git  repo: https://github.com/dubulingbo/dubulingbo.github.io.git  branch: gh-pages\n\n部署在项目的根目录root下，执行\nhexo deploy  #或者 hexo d\n\n\n\n​       至此，您的博客就已经成功部署到github上，并且通过键入 你的github账号.github.io 就能访问呢。感谢无名大佬们，让我终于倒腾出来了，后续再去弄清楚配置一键部署。\n参考资料\nhttps://hexo.io/zh-cn/docs/github-pages\nhttps://blog.csdn.net/Night__breeze/article/details/117607049\n\n\n\n① 如果这么配置，将会出现静态资源文件获取404，且访问博客首页时需得叫上仓库名才行，即 你的github账号.github.io/仓库名\n","categories":["Hexo博客搭建及主题美化"],"tags":["Hexo","教程","Github Pages"]},{"title":"每日一题：字符流","url":"/shuati-solution/dt1032/","content":"\n设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 words 中的一个字符串。\n\n例如，words &#x3D; [“abc”, “xyz”] 且字符流中逐个依次加入 4 个字符 ‘a’、’x’、’y’ 和 ‘z’ ，你所设计的算法应当可以检测到 “axyz” 的后缀 “xyz” 与 words 中的字符串 “xyz” 匹配。\n\n按下述要求实现 StreamChecker 类：\n\nStreamChecker(String[] words) ：构造函数，用字符串数组 words 初始化数据结构。\nboolean query(char letter)：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 words 中的某一字符串，返回 true ；否则，返回 false。\n\n\n\n\n\n\n\n题目链接：https://leetcode.cn/problems/stream-of-characters/\n\n解题思路暴力模拟：最多存储 max(words[i].length()) 个字符，每次存储字符前需要进行移位操作；\n提交记录\n代码class StreamChecker &#123;    private final Set&lt;String&gt; set;    private final int min;    // private final int max;    private char[] data;    private int size;    public StreamChecker(String[] words) &#123;        int mint = 201;        int maxt = 0;        set = new HashSet&lt;&gt;();        for (String w : words) &#123;            set.add(w);            mint = Math.min(mint, w.length());            maxt = Math.max(maxt, w.length());        &#125;        min = mint;        data = new char[maxt];        size = 0;    &#125;    public boolean query(char letter) &#123;        put(letter);        if (size &lt; min) return false;        // StringBuilder sb = new StringBuilder(new String(data, size + 1 - min, min));        StringBuilder sb = new StringBuilder(new String(data, size + 1 - min, min - 1));                for (int i = min; i &lt;= size; ++i) &#123;            sb.insert(0, data[size - i]);            if (set.contains(sb.toString())) &#123;                return true;            &#125;        &#125;                return false;    &#125;    private void put(char c) &#123;        int cnt = data.length;        if (size &gt;= cnt) &#123;            // 已存满            // System.arraycopy(data, 1, data, 0, cnt - 1);            for (int i = 0; i &lt; cnt - 1; ++i) &#123;                data[i] = data[i + 1];            &#125;            data[cnt - 1] = c;            return;        &#125;        data[size++] = c;    &#125;&#125;/** * Your StreamChecker object will be instantiated and called as such: * StreamChecker obj = new StreamChecker(words); * boolean param_1 = obj.query(letter); */\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"力扣第99场双周赛题解","url":"/shuati-solution/bct99/","content":"\n\n题目链接：https://leetcode.cn/contest/biweekly-contest-99/\n\n第一题：排序 + 奇偶分组解题思路\n分解每一位数字，并将它们进行排序\n从第一个不为零的数字开始，进行奇偶分离，再重新组成的两个整数和就是最小和\n\n提交结果\n代码class Solution &#123;    public int splitNum(int num) &#123;        int[] d = new int[10];        int n = 0;                while (num &gt; 0) &#123;            ++d[num % 10];            num /= 10;        &#125;                // 从小到大排序后，【奇数下标表示的数 + 偶数下标表示的数】就是最小的和        int odd = 0;        int even = 0;        boolean isOdd = false;        int i = 1;        while (i &lt; d.length) &#123;            if (d[i] &lt; 1) &#123;                ++i;                continue;            &#125;            if (isOdd) odd = odd * 10 + i;            else even = even * 10 + i;            isOdd = !isOdd;            --d[i];        &#125;                return even + odd;    &#125;&#125;\n\n第二题：数学找规律解题思路\n规律为：\n1：1\n2：1 + 3 + 1\n3：1 + 3 + 5 + 3 + 1\n4：1 + 3 + 5 + 7 + 5 + 3 + 1\n……\n\n\n于是，两个等差数列求和：(1 + 2 * n - 1) * n / 2 * 2 - 2 * n + 1 = n*n + (n - 1) * (n - 1)\n\n提交结果\n代码class Solution &#123;    public long coloredCells(int n) &#123;        long nn = n;        return nn*nn + (nn - 1) * (nn - 1);    &#125;&#125;\n\n第三题：贪心 + 区间排序 + 数学统计解题思路\n统计不相交的区间集合数group\n对于每个集合，都有两种选择，即属于 A 组或 B 组，故答案就是 2^group\n\n提交结果\n代码class Solution &#123;    public int countWays(int[][] ranges) &#123;        int n = ranges.length;        final int MOD = (int) (1e9 + 7);        // 统计无交集区间的组数        int group = 0;        int r = Integer.MIN_VALUE;        // 对于每个独立的区间组，都可以选择放入a组或b组，故答案就是 2^group        long res = 1L;        Arrays.sort(ranges, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]);        for (int i = 0; i &lt; n; ++i) &#123;            if (ranges[i][0] &gt; r) &#123;                ++group;                res = (res * 2) % MOD;                r = ranges[i][1];                continue;            &#125;            r = Math.max(r, ranges[i][1]);        &#125;                return (int) res;    &#125;&#125;\n\n\n","categories":["刷题题解"],"tags":["leetcode","题解","双周赛"]},{"title":"力扣第100场双周赛题解","url":"/shuati-solution/bct100/","content":"\n\n题目链接：https://leetcode.cn/contest/biweekly-contest-100/\n\n将钱分给最多的儿童解题思路按照题目分情况讨论即可\n提交结果\n代码class Solution &#123;    public int distMoney(int money, int children) &#123;        if (children &gt; money) return -1;        if (children * 8 &gt; money) &#123;            int x = money / 8;            int y = money % 8;            if (children - x == 1 &amp;&amp; y == 4) return x - 1;            // 每人分一美元后，再看还有多少组 7 美元即可            return (money - children) / 7;        &#125; else if (children * 8 &lt; money) &#123;            return children - 1;        &#125; else &#123;            return children;        &#125;    &#125;&#125;# [最大化数组的伟大值](https://leetcode.cn/problems/maximize-greatness-of-an-array/)## 解题思路：贪心 + 双指针  整个数组排序后，始终拿最大的与第二大的配对，如果相等，则需要与更小的配对；如果大于，结果直接加一，继续给剩余最大的数进行配对；直到遍历完整个数组。## 代码``` javaclass Solution &#123;    public int maximizeGreatness(int[] nums) &#123;        Arrays.sort(nums);        int n = nums.length;        int k = n -1;        int ret = 0;        for (int i = n - 2; i &gt;= 0; --i) &#123;            if (nums[k] &gt; nums[i]) &#123;                ++ret;                --k;            &#125;        &#125;                return ret;    &#125;&#125;\n\n标记所有元素后数组的分数思路：模拟 + 排序优化按照题意模拟即可，只不过可以加快每次寻找最小值的速度，用数组同时保存nums[i]与i，再进行升序排序，这样依次取到最小的数，同时用原数组进行标记已经被标记的数，直接赋值-1即可。\n代码class Solution &#123;    public long findScore(int[] nums) &#123;        int n = nums.length;        int[][] arr = new int[n][2];        for (int i = 0; i &lt; n; ++i) &#123;            arr[i][0] = i;            arr[i][1] = nums[i];        &#125;        Arrays.sort(arr, (o1, o2) -&gt; o1[1] == o2[1] ? o1[0] - o2[0] : o1[1] - o2[1]);                long score = 0;        for (int i = 0; i &lt; n; ++i) &#123;            int j = arr[i][0];            if (nums[j] &gt; -1) &#123;                // 当前最小值可选                score += arr[i][1];                // 标记周围的数                if (j &gt; 0) nums[j - 1] = -1;                if (j &lt; n - 1) nums[j + 1] = -1;            &#125;        &#125;        return score;    &#125;&#125;\n\n修车的最少时间法一：暴力对每一辆车分配给当前能最快完成修理工作的工人，这里就需要记录每位工人修理的汽车数量。为了能较快地找到当前修理最快的工人，根据修理当前车辆所花时间建立小顶堆。\n代码class Solution &#123;    public long repairCars(int[] ranks, int cars) &#123;        int n = ranks.length;        long spend = 0;        // 每位工人修车的数量        int[] rc = new int[n];        Arrays.fill(rc, 1);        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;            long l1 = (long) ranks[o1] * rc[o1] * rc[o1];            long l2 = (long) ranks[o2] * rc[o2] * rc[o2];            return (int) (l1 - l2);        &#125;);                for (int i = 0; i &lt; n; ++i) pq.offer(i);                for (int k = 1; k &lt;= cars; ++k) &#123;            // 第 k 辆车交给谁来修            // 选择花费时间最小的工人            int j = pq.poll();            long min = (long) ranks[j] * rc[j] * rc[j];            spend = Math.max(spend, min);            // 累加当前工人的修车数量            ++rc[j];            pq.offer(j);        &#125;        return spend;    &#125;&#125;\n\n当前时间复杂度：O(n*logn)，有超时的风险！\n法二：二分法参考：https://leetcode.cn/problems/minimum-time-to-repair-cars/solution/er-fen-da-an-pythonjavacgo-by-endlessche-keqf/\n代码class Solution &#123;    public long repairCars(int[] ranks, int cars) &#123;        long min = Arrays.stream(ranks).min().orElse(0);        long l = 0, r = min * cars * cars;                while (l + 1 &lt; r) &#123;            long m = (l + r) / 2;            long t = 0;                        for (int g : ranks) &#123;                t += Math.sqrt(m / g);            &#125;                        if (t &gt;= cars) r = m;            else l = m;        &#125;                return r;    &#125;&#125;\n\n","categories":["刷题题解"],"tags":["leetcode","题解","周赛"]},{"title":"每日一题：保证文件名唯一","url":"/shuati-solution/dt1487/","content":"题目链接:https://leetcode.cn/problems/making-file-names-unique/\n\n解题思路哈希表：存储当前新名字的下一个数字k；从左至右依次遍历names，如果当前name：\n\n不存在于哈希表中，该名字就是合理的，同时更新哈希表中name的k为1\n存在，则一直递增k，直到name + &quot;(&quot; + k + &quot;)&quot;不存在，此时，需要存储name的下一个数字为k+1，且新名字也要存于哈希表，即下一个数为1\n\n提交结果\n代码class Solution &#123;    public String[] getFolderNames(String[] names) &#123;        // 存储当前name的下一个数字k        Map&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; names.length; ++i) &#123;            int k = indexMap.getOrDefault(names[i], 0);            if (k == 0) &#123;                indexMap.put(names[i], 1);                continue;            &#125;            // 包含            String newName;            while (indexMap.containsKey((newName = suffix(names[i], k)))) &#123;                ++k;            &#125;                        // 当前文件的新名字为 xxx(k)            // 以前的名字的下标要往后移一个，即k+1            indexMap.put(names[i], k + 1);            // 新名字也要放入map，并更新下一个数字为1            indexMap.put(newName, 1);            names[i] = newName;        &#125;        return names;    &#125;    private String suffix(String name, int k) &#123;        return name + &quot;(&quot; + k + &quot;)&quot;;    &#125;&#125;\n\n","categories":["刷题题解"],"tags":["leetcode","刷题"]},{"title":"每日一题：递减元素使数组呈锯齿状","url":"/shuati-solution/dt1144/","content":"题目链接：https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/\n\n\n解题思路\n贪心 + 分类讨论\n\n假设，a,b,c是数组中三个连续下标的数，则考虑以下情况：\n\n当a,c都小于b时，很明显，这种情况不需要进行减一操作\n当a,c不都小于b（a&gt;=b || c&gt;=b）时，那么要想将数组变成锯齿数组所花费的操作数最少，只能对不满足条件的a或c进行减一操作综上所述，对于当前的数，每次只需要对与其相邻的两个数进行减一操作即可，因此可以分奇偶两种情况进行讨论，取操作数总和最小的。\n\n提交结果{width&#x3D;”400”}\n代码class Solution &#123;    public int movesToMakeZigzag(int[] nums) &#123;        int n = nums.length;        int[] arr = new int[n];        int even = 0;        int odd = 0;        System.arraycopy(nums, 0, arr, 0 , n);        // 考虑偶数索引        for (int i = 0; i &lt; n; i += 2) &#123;            even += cal(nums, i);        &#125;        // 考虑奇数索引        for (int i = 1; i &lt; n; i += 2) &#123;            odd += cal(arr, i);        &#125;        return Math.min(odd, even);    &#125;    private int cal(int[] nums, int i) &#123;        int ret = 0;        if (i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) &#123;            ret += (nums[i - 1] - nums[i] + 1);        &#125;        if (i &lt; nums.length - 1 &amp;&amp; nums[i] &lt;= nums[i + 1]) &#123;            ret += (nums[i + 1] - nums[i] + 1);            // 减到比nums[i]小一            nums[i + 1] = nums[i] - 1;        &#125;        return ret;    &#125;&#125;\n\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：最大网络秩","url":"/shuati-solution/dt1615/","content":"\n\n题目链接：https://leetcode.cn/problems/maximal-network-rank/\n\n解题思路\n记录每个城市的度\n然后枚举每两个城市即可获得最大秩\n\n提交结果\n代码class Solution &#123;    public int maximalNetworkRank(int n, int[][] roads) &#123;        int[] edgeCnt = new int[n];        boolean[][] connect = new boolean[n][n];                for (int[] r : roads) &#123;            ++edgeCnt[r[0]];            ++edgeCnt[r[1]];            connect[r[0]][r[1]] = true;        &#125;        int maxCnt = 0;        for (int i = 0; i &lt; n - 1; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                int cnt = (connect[i][j] || connect[j][i] ? -1 : 0) + edgeCnt[i] + edgeCnt[j];                maxCnt = Math.max(maxCnt, cnt);            &#125;        &#125;        return maxCnt;    &#125;&#125;\n\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：等差子数组","url":"/shuati-solution/dt1630/","content":"如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。\n\n\n\n题目链接：https://leetcode.cn/problems/arithmetic-subarrays/\n\n解题思路直接枚举每个区间进行判断，判断等差数列的方法可以有很多种，一般采用先排序，再判断是否为等差数列。\n提交结果\n代码class Solution &#123;    public List&lt;Boolean&gt; checkArithmeticSubarrays(int[] nums, int[] l, int[] r) &#123;        int n = l.length;        List&lt;Boolean&gt; retList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; n; ++i) &#123;            boolean b = check(nums, l[i], r[i]);            retList.add(b);        &#125;        return retList;    &#125;    private boolean check(int[] nums, int l, int r) &#123;        if (l &gt; r || r - l &lt; 2) return true;        int[] arr = new int[r - l + 1];        for (int i = l; i &lt;= r; ++i)            arr[i - l] = nums[i];        Arrays.sort(arr);        int d = arr[1] - arr[0];        for (int i = 2; i &lt; arr.length; ++i) &#123;            if (arr[i] - arr[i - 1] != d)                return false;        &#125;        return true;    &#125;&#125;","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"两点间不包含任何点的最垂直区域","url":"/shuati-solution/dt1637/","content":"给你 n 个二维平面上的点 points ，其中 points[i] &#x3D; [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。\n垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。\n请注意，垂直区域 边上 的点 不在 区域内。\n\n\n\n\n题目链接：https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/\n\n解题思路本题可以简化为求【横坐标的距离】，将points按横坐标进行升序排序，那么最大的垂直面积的宽度就是相邻两个横坐标差值的最大值。\n提交结果\n代码class Solution &#123;    public int maxWidthOfVerticalArea(int[][] points) &#123;        Arrays.sort(points, (a, b) -&gt; a[0] - b[0]);                int ret = 0;        for (int i = 1; i &lt; points.length; ++i) &#123;            ret = Math.max(points[i][0] - points[i-1][0], ret);        &#125;        return ret;    &#125;&#125;","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：统计字典序元音字符串的数目","url":"/shuati-solution/dt1641/","content":"给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。\n字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。\n\n\n\n\n题目链接：\n\n1. 解题思路将 a,e,i,o,u 标记为 0,1,2,3,4，则：\ndp[i][j] 表示 第 i 个位置上最大放置 j 的总方案数(i,j都从0开始)，可得出递推公式：\n\n当 j = 0 时，dp[i][j] = dp[i-1][j];\n当 j &gt; 0 时，dp[i][j] = dp[i-1][j] + dp[i][j-1];\n\n2. 运行结果\n3. 代码class Solution &#123;    public int countVowelStrings(int n) &#123;        int[][] dp = new int[n][5];        for (int i = 0; i &lt; 5; ++i) &#123;            dp[0][i] = i + 1;        &#125;        for (int i = 1; i &lt; n; ++i) &#123;            dp[i][0] = dp[i-1][0];            for (int j = 1; j &lt; 5; ++j) &#123;                dp[i][j] = dp[i][j - 1] + dp[i-1][j];            &#125;        &#125;        return dp[n-1][4];    &#125;&#125;","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：统计只差一个字符的子串数目","url":"/shuati-solution/dt1638/","content":"给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。\n比方说， “computer” and “computation” 只有一个字符不同： ‘e’&#x2F;‘a’ ，所以这一对子字符串会给答案加 1 。\n请你返回满足上述条件的不同子字符串对数目。\n一个 子字符串 是一个字符串中连续的字符。\n\n\n\n\n题目链接：https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/\n\n解题思路对 s,t 的每个下标开始位置进行枚举，如果当前字符相同，继续，否则，不同字符对加一，同时答案也 +1\n提交结果\n代码class Solution &#123;    public int countSubstrings(String s, String t) &#123;        char[] schs = s.toCharArray();        char[] tchs = t.toCharArray();        int sn = schs.length, tn = tchs.length;        int ans = 0;        for (int i = 0; i &lt; sn; ++i) &#123;            for (int j = 0; j &lt; tn; ++j) &#123;                int k = 0;                // 记录不同字符对的数量                int diff = 0;                while (i + k &lt; sn &amp;&amp; j + k &lt; tn) &#123;                    // 字符不相同，diff +1                    if (schs[i + k] != tchs[j + k])                        ++diff;                                        if (diff == 1) &#123;                        // 仅有一个不同的字符对，答案 +1                        ++ans;                    &#125; else if (diff &gt; 1) &#123;                        // 不同字符对超过 1，直接结束本次循环                        break;                    &#125;                    ++k;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：使字符串平衡的最少删除次数","url":"/shuati-solution/dt1653/","content":"题目链接：https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/\n\n解题思路\n根据题目意思，最后字符串应该是1）全是a，2）全是b，所有的a都在b的前面（即：aaaaaaaaabbbbbbb）\n\n那么，可以枚举分割点来计算删除的最小字符数：\n\n从左往右枚举 n + 1 个分割点，针对每一个分割点，左边必须全a，右边必须全b，两边删除的字符数求和就是点前分割点分割，达到平衡的删除字符数；如此取最小的即可\n优化：\n先统计从右到左子字符串中所有 a 的字符串，记录与数组\n\n\n\n提交结果\n代码class Solution &#123;    public int minimumDeletions(String s) &#123;        char[] chs = s.toCharArray();        int n = chs.length;        // [i, n - 1] 的 a 的数量        int[] racount = new int[n];        for (int i = n - 1; i &gt;= 0; --i) &#123;            racount[i] = chs[i] == &#x27;a&#x27; ? 1 : 0;            if (i &lt; n - 1) &#123;                racount[i] += racount[i + 1];            &#125;        &#125;        // 左边 b 的数量        int lbcount = 0;        int res = Integer.MAX_VALUE;        // 枚举每一个分割点        for (int i = 0; i &lt; n; ++i) &#123;            // [0, i) 为 a，[i, n - 1] 为 b            res = Math.min(res, lbcount + racount[i]);            lbcount += chs[i] == &#x27;b&#x27; ? 1 : 0;        &#125;        return Math.min(lbcount, res);    &#125;&#125;","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：合并相似的物品","url":"/shuati-solution/dt2363/","content":"题目链接：https://leetcode.cn/problems/merge-similar-items/\n\n\n解题思路简单的hash表应用，值得一提的是可以用数组表示hash表，这样可以省去排序的步骤，具体可看下面的源码。\n\n提交结果{width&#x3D;”400”}\n代码class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; mergeSimilarItems(int[][] items1, int[][] items2) &#123;        int[] w = new int[1001];        for (int[] it : items1) &#123;            w[it[0]] = it[1];         &#125;        for (int[] it : items2) &#123;            w[it[0]] += it[1];        &#125;        List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();        for (int i = 1; i &lt; w.length; ++i) &#123;            if (w[i] &gt; 0) &#123;                ret.add(Arrays.asList(i, w[i]));            &#125;        &#125;        return ret;    &#125;&#125;\n\n\n\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"算术三元组的数目","url":"/shuati-solution/dt2367/","content":"给你一个下标从 0 开始、严格递增的整数数组 nums 和一个正整数 diff 。如果满足下述全部条件，则三元组 (i, j, k) 就是一个算术三元组：\n\ni &lt; j &lt; k ，\nnums[j] - nums[i] == diff 且\nnums[k] - nums[j] == diff\n\n返回不同 算术三元组 的数目。\n\n\n解题思路整体思路是枚举，不过本题条件很多，比如数组是严格递增的，数组长度、数组的每个元素的数值较小，所以有三种方法进行求解：\n\n直接枚举每个元素，进行判断\n\n使用哈希表进行优化，即每次枚举最小的数nums[i]，那么就只需要判断 nums[i] + diff 与 nums[i] + 2 * diff 是否存在即可，故有以下两种优化方法：2. 使用 hashset3. 使用 boolean 数组\n法一：直接暴力class Solution &#123;    public int arithmeticTriplets(int[] nums, int diff) &#123;        int ans = 0;        int n = nums.length;        for (int i = 0; i &lt; n - 2; ++i) &#123;            for (int j = i + 1; j &lt; n - 1; ++j) &#123;                if (nums[j] - nums[i] == diff) &#123;                    for (int k = j + 1; k &lt; n; ++k) &#123;                        if (nums[k] - nums[j] == diff)                             ++ans;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;\n\n提交结果：\n\n法二：hashsetclass Solution &#123;    public int arithmeticTriplets(int[] nums, int diff) &#123;        int ans = 0;        int n = nums.length;        // 建立哈希表，便于快速查找某个数是否存在        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        for (int num : nums) set.add(num);        // nums严格递增，所以 nums[i]+diff, nums[i]+2*diff 出现在当前位置之后        for (int i = 0; i &lt; n - 2; ++i) &#123;            if (set.contains(nums[i] + diff) &amp;&amp; set.contains(nums[i] + 2 * diff)) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;\n\n提交结果：\n\n法三：数组模拟哈希表class Solution &#123;    public int arithmeticTriplets(int[] nums, int diff) &#123;        int ans = 0;        int n = nums.length;        // 数组模拟哈希表，便于快速查找某个数是否存在        boolean[] hash = new boolean[201];        for (int num : nums) hash[num] = true;        // nums严格递增，所以 nums[i]+diff, nums[i]+2*diff 出现在当前位置之后        for (int i = 0; i &lt; n - 2; ++i) &#123;            int x = nums[i] + 2 * diff;            // 数组严格递增，如果大于了数据范围，直接跳出循环            if (x &gt;= hash.length) break;            // 如果 nums[i]+x 和 nums[i]+2*diff 都存在，结果+1            if (hash[x - diff] &amp;&amp; hash[x]) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;\n\n提交结果：\n\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：按位与为零的三元组","url":"/shuati-solution/dt982/","content":"\n题目链接：https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/\n\n解题思路枚举：使用hash表 + 子集枚举进行优化\n具体思路请点这里 \n代码class Solution &#123;    public int countTriplets(int[] nums) &#123;        int n = nums.length;        // 数组代表哈希表        int[] cntMap = new int[1 &lt;&lt; 16]; // 65536        // 枚举前两个数        for (int a : nums) &#123;            for (int b : nums) &#123;                ++cntMap[a &amp; b];            &#125;        &#125;        // 0 &amp; 任意数都是 0        int res = n * cntMap[0];        // 枚举第三个数        for (int c : nums) &#123;            c = c ^ 0xffff;            for (int k = c; k != 0; k = (k - 1) &amp; c) &#123;                res += cntMap[k];            &#125;        &#125;        return res;    &#125;&#125;\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"每日一题：隐藏个人信息","url":"/shuati-solution/dt831/","content":"给你一条个人信息字符串 s ，可能表示一个 邮箱地址 ，也可能表示一串 电话号码 。\n题目链接：https://leetcode.cn/problems/masking-personal-information\n\n\n\n\n题目链接：https://leetcode.cn/problems/masking-personal-information\n\n解题思路直接按题意模拟，分别处理电话号码和邮箱即可。\n两种字符串拼接比较\n使用String.format()\n\nclass Solution &#123;    public String maskPII(String s) &#123;        int at = s.indexOf(&#x27;@&#x27;);        if (at != -1) &#123;            // 是邮箱            if (at &gt; 0) &#123;                char first = Character.toLowerCase(s.charAt(0));                char last = Character.toLowerCase(s.charAt(at - 1));                String domain = s.substring(at + 1).toLowerCase();                return String.format(&quot;%c*****%c@%s&quot;, first, last, domain);            &#125; else &#123;                return &quot;&quot;;            &#125;        &#125; else &#123;            // 是电话号码            char[] chs = s.toCharArray();            int k = 0;            for (int i = 0; i &lt; chs.length; ++i) &#123;                if (chs[i] &gt;= &#x27;0&#x27; &amp;&amp; chs[i] &lt;= &#x27;9&#x27;) &#123;                    chs[k++] = chs[i];                &#125;            &#125;            if (k &lt; 10) return &quot;&quot;;            String ph = new String(chs, k - 4, 4);            if (k == 10) &#123;                return String.format(&quot;***-***-%s&quot;, ph);            &#125; else &#123;                StringBuilder sb = new StringBuilder();                while (k &gt; 10) &#123;                    sb.append(&#x27;*&#x27;);                    --k;                &#125;                return String.format(&quot;+%s-***-***-%s&quot;, sb.toString(), ph);            &#125;        &#125;    &#125;&#125;\n\n\n\n使用StringBuilder\n\nclass Solution &#123;    public String maskPII(String s) &#123;        int at = s.indexOf(&#x27;@&#x27;);        if (at != -1) &#123;            // 是邮箱            if (at &gt; 0) &#123;                StringBuilder ret = new StringBuilder();                ret.append(Character.toLowerCase(s.charAt(0)))                     .append(&quot;*****&quot;)                     .append(Character.toLowerCase(s.charAt(at - 1)))                     .append(s.substring(at).toLowerCase());                return ret.toString();            &#125; else &#123;                return &quot;&quot;;            &#125;        &#125; else &#123;            // 是电话号码            char[] chs = s.toCharArray();            int k = 0;            for (int i = 0; i &lt; chs.length; ++i) &#123;                if (chs[i] &gt;= &#x27;0&#x27; &amp;&amp; chs[i] &lt;= &#x27;9&#x27;) &#123;                    chs[k++] = chs[i];                &#125;            &#125;            if (k &lt; 10) return &quot;&quot;;            StringBuilder sb = new StringBuilder();            String ph = new String(chs, k - 4, 4);            if (k == 10) &#123;                sb.append(&quot;***-***-&quot;).append(ph);            &#125; else &#123;                sb.append(&#x27;+&#x27;);                while (k &gt; 10) &#123;                    sb.append(&#x27;*&#x27;);                    --k;                &#125;                sb.append(&quot;-***-***-&quot;).append(ph);            &#125;            return sb.toString();        &#125;    &#125;&#125;\n\n\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"面试题 05.02：二进制数转字符串","url":"/shuati-solution/dt_ms_05_02/","content":"\n题目链接：https://leetcode.cn/problems/bianry-number-to-string-lcci/\n\n法一\n直接模拟计算，直到超出，具体看源码\n\nclass Solution &#123;    public String printBin(double num) &#123;        char[] chs = String.valueOf(num).toCharArray();        int n = chs.length;        // 题目保证最后只有6位小数，因此最多循环10次        final int N = 10;        // 被减数        int a;        // 减数        int b = 5;        // 余数        int d = 0;                StringBuilder sb = new StringBuilder(&quot;0.&quot;);        for (int i = 0; i &lt; N; ++i) &#123;            a = d * 10 + (i + 2 &lt; n ? chs[i + 2] - &#x27;0&#x27; : 0);            if (a &gt;= b) &#123;                sb.append(1);                d = a - b;                if (a == b &amp;&amp; i + 2 == n - 1) break;            &#125; else &#123;                sb.append(0);                d = a;            &#125;            b *= 5;        &#125;        return d == 0 ? sb.toString() : &quot;ERROR&quot;;    &#125;&#125;\n\n提交结果\n法二解题思路总结归纳：一直乘以 2，直到变成 1，或者无线循环下去；因为题目要求，故仅需要循环30次即可。\n提交结果\n源码class Solution &#123;    public String printBin(double num) &#123;        StringBuilder res = new StringBuilder(&quot;0.&quot;);        while (res.length() &lt;= 32 &amp;&amp; num != 0) &#123;            num *= 2;            if (num &gt;= 1) &#123;                res.append(1);                num -= 1;            &#125; else &#123;                res.append(0);            &#125;        &#125;        return res.length() &gt; 32 &amp;&amp; num != 0 ? &quot;ERROR&quot; : res.toString();    &#125;&#125;\n","categories":["刷题题解"],"tags":["leetcode","题解"]},{"title":"力扣第334场周赛题解","url":"/shuati-solution/wct334/","content":"\n\nT1. 后缀和，模拟\n题目链接：https://leetcode.cn/problems/left-and-right-sum-differences/\n\n代码\nclass Solution &#123;    public int[] leftRigthDifference(int[] nums) &#123;        int n = nums.length;        int[] rightSum = new int[n];        int leftSum = 0;        int[] ret = new int[n];                for (int i = n - 2; i &gt;= 0; --i) &#123;            rightSum[i] = rightSum[i + 1] + nums[i+1];        &#125;                for (int i = 0; i &lt; n; ++i) &#123;            ret[i] = Math.abs(leftSum - rightSum[i]);            leftSum += nums[i];        &#125;                return ret;    &#125;&#125;\n\nT2. 模拟\n题目链接：https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/\n\n解题思路如果一个数num能被m整除，其除个位外的整数为 high = num / 10，个位为 low = num % 10；那么就会满足：\n\n如果high能被m整除，则low也要能被m整除\n如果high不能被m整除，则 high % m * 10 + low 要能被m整除综上：high % m * 10 + low 要能被m整除，需要注意的int溢出问题\n\n\n代码\nclass Solution &#123;    public int[] divisibilityArray(String word, int m) &#123;        char[] chs = word.toCharArray();        int n = chs.length;        int[] ret = new int[n];        long mod = 0;                for (int i = 0; i &lt; n; ++i) &#123;            mod = (mod * 10 + chs[i] - &#x27;0&#x27;) % m;            ret[i] = mod == 0 ? 1 : 0;        &#125;                return ret;    &#125;&#125;\n\nT3. 贪心 + 排序\n题目链接：https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/\n\n解题思路因为最多标记 nums.length / 2 对数；因此可以将数组进行排序，排完序后，则可以在左右半边各选一个数，如此可以找到尽可能多的数对。所以就是让左半边大的数与右半边大的数组队。\n\n代码\nclass Solution &#123;    public int maxNumOfMarkedIndices(int[] nums) &#123;        int n = nums.length;        if (n &lt; 2) return 0;                Arrays.sort(nums);                int ans = 0;        int mid = n / 2;        int l = mid - 1;        int r = n - 1;                while (l &gt;= 0 &amp;&amp; r &gt;= mid) &#123;            if (2 * nums[l] &lt;= nums[r]) &#123;                --l;                --r;                ans += 2;            &#125; else &#123;                // 不匹配时，l减少                // 如此才不会影响它左侧的数找“伙伴”                --l;            &#125;        &#125;                return ans;    &#125;&#125;\n\n","categories":["刷题题解"],"tags":["leetcode","题解","周赛"]},{"title":"力扣第335场周赛题解","url":"/shuati-solution/wct335/","content":"\n\n题目链接：https://leetcode.cn/contest/weekly-contest-335/\n\n第一题：模拟解题思路简单的按题意模拟即可\n提交结果\n代码class Solution &#123;    public int passThePillow(int n, int time) &#123;        int cur = 1;        int dir = 1;        while (--time &gt;= 0) &#123;            cur += dir;            if (cur &gt; n) &#123;                cur = n - 1;                dir = -1;            &#125; else if (cur &lt; 1) &#123;                cur = 2;                dir = 1;            &#125;         &#125;                return cur;    &#125;&#125;\n\n\n第二题：BFS解题思路\nBFS一遍记录每一层的和\n对每一层和进行排序后，就能直接得到第 k 大的层和\n\n提交结果\n代码/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */class Solution &#123;    public long kthLargestLevelSum(TreeNode root, int k) &#123;        List&lt;Long&gt; list = new ArrayList&lt;&gt;();                Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();        que.offer(root);                while (!que.isEmpty()) &#123;            long sum = 0;            for (int i = que.size(); i &gt; 0; --i) &#123;                root = que.poll();                sum += root.val;                                if (root.left != null) que.offer(root.left);                if (root.right != null) que.offer(root.right);            &#125;            list.add(sum);        &#125;                Collections.sort(list);                return list.size() &lt; k ? -1 : list.get(list.size() - k);    &#125;&#125;\n\n\n第三题：\n暂时没想到好方法\n\n","categories":["刷题题解"],"tags":["leetcode","题解","周赛"]},{"title":"力扣第337场周赛题解","url":"/shuati-solution/wct338/","content":"力扣第338场周赛前三题题解\n题目链接：https://leetcode.cn/contest/weekly-contest-338\n\n\nT1. K 件物品的最大和\n题目链接：https://leetcode.cn/problems/k-items-with-the-maximum-sum/\n\n思路贪心，先取1，再取0，最后取-1的物品\n代码public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) &#123;    if (numOnes + numZeros &gt;= k) &#123;        return numOnes &gt; k ? k : numOnes;    &#125; else &#123;        return numOnes - (k - numOnes - numZeros);    &#125;&#125;\n\n\n\nT2. 质数减法运算\n题目链接：https://leetcode.cn/problems/prime-subtraction-operation/\n\n思路判断质数的算法质数，是大于 1 的自然数，且它的因数只有 1 和它本身。一般判断质数的算法有两种，一种是利用定义判断，一种是用质数表，以下的Java的实现。\n\n定义判断\n\npublic boolean isPrime(int k) &#123;    if (k &lt; 2) return false;    int q = (int) Math.sqrt(k);    for (int i = 2; i &lt;= q; ++i) &#123;        if (k % i == 0) return false;    &#125;    return true;&#125;\n\n\n质数表算法，一般适用于求取某个范围内的所有质数\n\n// 求取 [0, r] 以内的质数算法public boolean[] prime(int r) &#123;    // false - 是质数    // true - 不是质数    boolean[] nonPrime = new boolean[r + 1];        // Sieve of Eratosthenes algorithm    nonPrime[1] = true;    for (int i = 2; i * i &lt;= r; i++) &#123;        for (int j = i * i; j &lt;= r; j += i) &#123;            nonPrime[j] = true;        &#125;    &#125; \t    return nonPrime;&#125;\n\n\n\n本题思路贪心 + 判断质数\n\n从左到右遍历数组nums，下标从 1 开始（一个元素肯定就是严格递增的），\n若 nums[i-1] &lt; nums[i]，继续遍历\n否则，从最右边选择第一个没有操作过的下边开始做质数减法，尽可能让被减的质数最大，具体看代码注释\n\n\n\n代码class Solution &#123;    public boolean primeSubOperation(int[] nums) &#123;        int n = nums.length;        // 最右边未选择的下标        int pre = 0;        for (int i = 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; nums[i - 1]) continue;            // 从最左边开始减少            while (pre &lt; i) &#123;                // nums[pre] 从最小值开始枚举                int k = pre == 0 ? 1 : nums[pre - 1] + 1;                int min = Math.min(nums[pre], nums[pre + 1]);                while (k &lt; min &amp;&amp; !isPrime(nums[pre] - k)) &#123;                    ++k;                &#125;                // k 可以等于 nums[pre]，但是必须小于 nums[pre]                if (k &gt;= nums[pre + 1]) return false;                nums[pre++] = k;            &#125;        &#125;        return true;    &#125;    private boolean isPrime(int k) &#123;        if (k &lt; 2) return false;        int q = (int) Math.sqrt(k);        for (int i = 2; i &lt;= q; ++i) &#123;            if (k % i == 0) return false;        &#125;        return true;    &#125;&#125;\n\n也能用质数表实现快速判断质数\nclass Solution &#123;    public boolean primeSubOperation(int[] nums) &#123;        int n = nums.length;        // 建立质数表        // true - 非质数        // false - 质数        boolean[] nonPrime = new boolean[1000];        nonPrime[1] = true;        for (int i = 2; i * i &lt; 1000; ++i) &#123;            for (int j = i + i; j &lt; 1000; j += i) &#123;                nonPrime[j] = true;            &#125;        &#125;                // 最右边未选择的下标        int pre = 0;        for (int i = 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; nums[i - 1]) continue;            // 从最左边开始减少            while (pre &lt; i) &#123;                // nums[pre] 从最小值开始枚举                int k = pre == 0 ? 1 : nums[pre - 1] + 1;                int min = Math.min(nums[pre], nums[pre + 1]);                while (k &lt; min &amp;&amp; nonPrime[nums[pre] - k]) &#123;                    ++k;                &#125;                if (k &gt;= nums[pre + 1]) return false;                nums[pre++] = k;            &#125;        &#125;        return true;    &#125;&#125;\n\n\n\n提交结果\nT3. 使数组元素全部相等的最少操作次数思路二分 + 前缀和\n\n对 nums 进行排序\n\n记录 nums 的前缀和数组sum\n\n枚举每一个query，二分查找query在nums中插入位置k，即：\n\n对于 0&lt;=i&lt;=k-1，都有 nums[i]&lt;=query\n\n对于 k&lt;=i&lt;=n-1，都有 nums[i]&gt;query\n\n\n\n那么当前最少的操作数就是 k * q - sum[k - 1] + sum[n-1] - sum[k-1] - q * (n - k)\n\n\n代码class Solution &#123;    public List&lt;Long&gt; minOperations(int[] nums, int[] queries) &#123;        int n = nums.length;                Arrays.sort(nums);                long[] sum = new long[n];                sum[0] = nums[0];        for (int i = 1; i &lt; n; ++i) &#123;            sum[i] = sum[i-1] + nums[i];        &#125;                List&lt;Long&gt; ret = new ArrayList&lt;&gt;();        for (int q : queries) &#123;                        int k = binary(nums, q);            // nums[0 ... k-1] &lt;= q &amp;&amp; nums[k ... n-1] &gt; q                        if (k == 0) &#123;                ret.add(sum[n - 1] - (long) n * q);            &#125; else if (k == n) &#123;                ret.add((long) n * q - sum[n - 1]);            &#125; else &#123;                ret.add(((long)k * q - sum[k - 1]) + (sum[n-1] - sum[k-1] - (long) q * (n - k)));            &#125;        &#125;                return ret;    &#125;        private int binary(int[] nums, int target) &#123;        int l = 0;        int r = nums.length;                while (l &lt; r) &#123;            int m = (l + r) / 2;            if (nums[m] &lt;= target) l = m + 1;            else r = m;        &#125;                return l;    &#125;&#125;\n\n\n\n提交结果\n","categories":["刷题题解"],"tags":["leetcode","题解","周赛"]},{"title":"力扣第337场周赛题解","url":"/shuati-solution/wct337/","content":"\n\n题目链接：https://leetcode.cn/contest/weekly-contest-337/\n\n奇偶位数代码class Solution &#123;    public int[] evenOddBit(int n) &#123;        int k = 0, e = 0, o = 0;        while (n &gt; 0) &#123;            int t = n % 2;            if(n % 2 == 1) &#123;                if ((k &amp; 1) == 1) ++o;                else ++e;            &#125;            n /= 2;            ++k;        &#125;        return new int[] &#123;e , o&#125;;    &#125;&#125;\n\n检查骑士巡视方案解题思路将 0 ~ n*n - 1 这个n*n对坐标存入长度为 n*n 的数组，然后依次从0开始遍历该数组，同时记录上一个位置的下标，满足条件则继续，不满足则直接返回 false。\n提交结果\n代码class Solution &#123;    public boolean checkValidGrid(int[][] grid) &#123;        int n = grid.length;        if (grid[0][0] != 0) return false;        int[][] arr = new int[n * n][2];                for (int i = 0; i &lt; n; ++i) &#123;            for (int j = 0; j &lt; n; j++) &#123;                arr[grid[i][j]][0] = i;                 arr[grid[i][j]][1] = j;             &#125;        &#125;                int x = 0, y = 0;        for (int i = 1; i &lt; n * n; ++i) &#123;            int nx = arr[i][0];            int ny = arr[i][1];                        if ((Math.abs(nx - x) == 2 &amp;&amp; Math.abs(ny - y) == 1)                     || (Math.abs(ny - y) == 2 &amp;&amp; Math.abs(nx - x) == 1)) &#123;                x = nx;                y = ny;            &#125; else &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n\n执行操作后的最大 MEX解题思路\n统计nums中所有的数对value取余后的分布情况，使用hashmap存储余数的个数\n从0到n枚举缺少的最小非负整数，同时更新hash表即可\n\n\n需要注意的是 java 中负数取余操作：  比如 -3 % 4 &#x3D; -3，但是题目意思应该-3可以变为1，  因此对于负数，应该是：nums[i] % value + value，而对于非负整数取余就是 nums[i] % value，  综上，本题取余操作应该是：(nums[i] % value + value) % value\n\n提交结果\n代码class Solution &#123;    public int findSmallestInteger(int[] nums, int value) &#123;        int n = nums.length;        Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();        for (int num : nums) &#123;            int mod = (num % value + value) % value;            cnt.put(mod, cnt.getOrDefault(mod, 0) + 1);        &#125;        int ret = 0;        for (int i = 0; i &lt; n; ++i) &#123;            int mod = ret % value;            int c = cnt.getOrDefault(mod, 0);            // 没法获得当前的 ret，            if (c &lt; 1) break;                        cnt.put(mod, c - 1);            // 继续下一个数枚举            ++ret;        &#125;                return ret;    &#125;&#125;\n","categories":["刷题题解"],"tags":["leetcode","题解","周赛"]},{"title":"~看心情写写欸~","url":"/suibi/jixing/","content":"读书之三种境界\n\n昨夜西风凋碧树，独上高楼，望尽天涯路\n\n衣带渐宽终不悔，为伊消得人憔悴\n\n众里寻他千百度，蓦然回首，那人却在灯火阑珊处\n\n\n\n\n\n\n爱究竟多深，才能变成憎恨\n执念扎根，篡改两个人生\n江湖已沉沦，无处可栖身\n嗜血的兵刃，收起天真\n因为无缺，所以不识烟火红尘\n因为无心，所以是性情人\n因为无缘，再多精明都变愚钝\n不留余恨，我奋不顾身\n堕入宿命挣不脱的灵魂，屈从和服输岂肯\n剑出鞘斩断心中的疑问，恩怨破阵\n世上最高深的武功现身，爱让人疯癫心疼\n风干的泪痕是我在强忍，抵不过造化弄人\n爱究竟多深，才能变成憎恨\n执念扎根，篡改两个人生\n江湖已沉沦，无处可栖身\n嗜血的兵刃，收起天真\n因为无缺，所以不识烟火红尘\n因为无心，所以是性情人\n因为无缘，再多精明都变愚钝\n不留余恨，我奋不顾身\n堕入宿命挣不脱的灵魂\n屈从和服输岂肯\n剑出鞘斩断心中的疑问\n恩怨破阵\n世上最高深的武功现身\n爱让人疯癫心疼\n风干的泪痕是我在强忍\n敌不过造化弄人\n堕入宿命挣不脱的灵魂，屈从和服输岂肯\n剑出鞘斩断心中的疑问，恩怨破阵\n世上最高深的武功现身，爱让人疯癫心疼\n风干的泪痕是我在强忍，敌不过造化弄人\n你我双生同根\n\n水月栖霞，散琼飞花\n抵不过阡陌蒹葭\n檐雀叽喳，桨声咿呀\n仿佛流过刹那，烟雨笼轻纱\n少年不识红尘好\n月冷星怜不寂寥\n看春秋书写，梦里眷恋人间道\n有一座命注定的桥，情人筑就，插翅难逃\n纵然穿心剔骨，不悔年少\n人行天涯，剑倚天下\n眼底藏一树桃花\n一曲琵琶，一盏清茶\n疏影横过芳华\n无语也牵挂\n少年不识红尘好\n月冷星怜不寂寥\n看春秋书写\n梦里眷恋人间道\n有一座命注定的桥，情人筑就，插翅难逃\n等到尘埃落定，回首那江上，明月上柳梢\n少年不识红尘好，月冷星怜不寂寥\n看春秋书写，梦里眷恋人间道\n有一座命注定的桥，情人筑就，插翅难逃\n纵然穿心剔骨，不悔年少\n\n这个世界有多甜 眷顾平凡的少年\n借你的笑颜，地球转一圈\n好把一辈子晕眩\n别偷听我的心愿，我想它已经灵验\n等无边的黑夜，输给地平线\n见证孤单的终点\n我们还有好多好多年，将未完的预言都实现\n锁在日记手写的誓言\n你仿佛狂奔，赶来拥抱我的长街\n我不管他们说多少至理名言，我除了你没有第二志愿\n就用这青春的手验算永远的远\n我明白总有些遗憾无法幸免，只求这场告白不算荒年\n感谢 你说你很乐意去揭开一切悬念\n滴答滴答 我们的遇见\n滴答滴答 我们就永远\n我们还有好多好多年，也许每一步都是瓦解\n如果时间问你怎么选\n麻烦你的心，可以偏向我的这边\n我不管他们说多少至理名言，我除了你没有第二志愿\n就用这青春的手验算永远的远\n我明白总有些遗憾无法幸免，只求这场告白不算荒年\n感谢 你说你很乐意去揭开一切悬念\n我不管他们说什么天高路远，我除了你没有第二志愿\n就让鸽子去蓝天，悲伤送给诗篇\n我明白总有些遗憾只能亏欠，但求这本旅途终章喜悦\n感谢 你说你很乐意去陪我抵达明天\n滴答滴答 你视而不见\n滴答滴答 你百看不厌\n\n努力不为感动谁，只为不与最好的自己失之交臂！\n这一秒不放弃，下一秒就有机会\nWhere there is a will, there is a way\n\n\n\n  In front of a desktop sits a young boy is staring at the screen and selecting the curriculum. Apparently, a trace of hesitancy showed in his eyes. He is considering whether to choose the courses which are high scored, easily passed with less homework, or to choose those that cantain new knowledge, focus on creating ans are difficult to learn.\n   The implication echoed by this cartoon can be summarized as a philosophic topic in our daily life: the success of a man is closely related to the choice made by himself. Nevertheless, I cherish a belief that we cannot tell whether the selection is good or not, and as long as we adhere to our decision, success will be realized step by step. Although making a choice is essential to help determine the direction of our way, judged from the personal aspect, persistence functions as an indispensable driving force to keep up our spirit and to assist us to fulfill our study and work. However, some people, pacing up and down, are not industrious and try to find a short-cut success. In fact, only those who are hard-working and brave enough to encounter obstacles of all sorts are most likely to reach the summit of success.\n   Accordingly persistence and making our decision rationally are badly needed in every aspect of our society. In order to bring out this potential capability, our education system is supposed to be reformed fundamentally, focusing on cultivating the ability of confrontinh challenges, As an old saying goes: “No pain, no gain.”\n\n","categories":["随笔"],"tags":["随笔"]},{"title":"安装Docker","url":"/tutorial/docker-install/","content":"主要介绍在 Centos7 上安装和配置 Docker 容器，以及 DockerCompose 的安装与配置。\n\n\n1. 安装DockerDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。\nDocker CE 分为 stable test 和 nightly 三个更新频道。\n官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。\n2. CentOS安装DockerDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。\n2.1 卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载：\nyum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-selinux \\                  docker-engine-selinux \\                  docker-engine \\                  docker-ce\n\n2.2 安装docker首先需要大家虚拟机联网，安装yum工具\nyum install -y yum-utils \\           device-mapper-persistent-data \\           lvm2 --skip-broken\n\n然后更新本地镜像源：\n# 设置docker镜像源yum-config-manager \\    --add-repo \\    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fast\n\n然后输入命令：\nyum install -y docker-ce\n\n2.3 启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！\n启动docker前，一定要关闭防火墙后！！\n# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld\n\n\n\n通过命令启动docker：\nsystemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务\n\n\n\n然后输入命令，可以查看docker版本：\ndocker -v# 或systemctl status docker \n\n2.4 配置镜像加速docker官方镜像仓库网速较差，需要设置国内镜像服务（需要登录阿里云）：\n参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n3. CentOS7安装DockerCompose3.1 下载与安装Linux下需要通过命令下载：\n# 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n\n\n\n3.2 修改文件权限修改文件权限：\n# 修改权限chmod +x /usr/local/bin/docker-compose\n\n3.3 Base自动补全命令：# 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n\n如果这里出现错误，需要修改自己的hosts文件：\necho &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts\n\n\n4. Docker镜像仓库搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。\n官网地址：https://hub.docker.com/_/registry\n4.1 简化版镜像仓库Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。\n搭建方式比较简单，命令如下：\ndocker run -d \\    --restart=always \\    --name registry\t\\    -p 5000:5000 \\    -v registry-data:/var/lib/registry \\    registry\n\n命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。\n访问http:&#x2F;&#x2F;你的机器IP:5000&#x2F;v2&#x2F;_catalog 可以查看当前私有镜像服务中包含的镜像\n4.2 带有图形化界面版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：\nversion: &#x27;3.0&#x27;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=【你的私库名称】      - REGISTRY_URL=http://registry:5000    depends_on:      - registry\n\n4.3 配置Docker信任地址私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：\n# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.150.101:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker","categories":["教程"],"tags":["Docker","安装教程"]},{"title":"安装Nacos","url":"/tutorial/nacos-install/","content":"Nacos安装教程，Nacos使用版本为：1.4.1\n\nWindows\nLinux\nMac\n\n1.Windows安装开发阶段采用单机安装即可。\n1.1.下载安装包在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：\nGitHub主页：https://github.com/alibaba/nacos\nGitHub的Release下载页：https://github.com/alibaba/nacos/releases\n如图：\n\n如果下载较慢，也可到网盘中获取：\n链接: https://pan.baidu.com/s/17ssXujh-t2wA5D-wx3W2jQ?pwd=zxcv 提取码: zxcv\n\nwindows版本使用nacos-server-1.4.1.zip包即可。\n1.2.解压将下载的压缩包解压到任意非中文目录下，如图：\n\n目录说明：\n\nbin：启动脚本\nconf：配置文件\n\n1.3.端口配置Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。\n如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口：\n\n修改其中的内容：\n\n1.4.启动启动非常简单，进入bin目录，结构如下：\n\n然后执行命令即可：\n\ncmd进入bin目录，执行以下windows命令：\nstartup.cmd -m standalone\n\n执行后的效果如图：\n\n1.5.访问在浏览器输入地址：http://127.0.0.1:8848/nacos即可：\n\n默认的账号和密码都是nacos，进入后：\n\n2.Linux、Mac安装Linux和Mac安装方式与Windows类似。\n2.1.安装JDKNacos依赖于JDK运行，所以Linux上也需要安装JDK（自行百度安装），然后再配置JAVA环境变量即可，博主使用的是Centos，推荐在/etc/profile文件末尾添加JAVA环境变量：\nexport JAVA_HOME=/usr/local/javaexport PATH=$PATH:$JAVA_HOME/bin\n\n设置环境变量：\nsource /etc/profile\n\n2.2.上传安装包如图：\n\n下载 nacos-server-1.4.1.tar.gz 到Linux服务器的某个目录，例如/usr/local/src目录下：\n\n2.3.解压命令解压缩安装包：\ntar -xvf nacos-server-1.4.1.tar.gz\n\n然后删除安装包：\nrm -rf nacos-server-1.4.1.tar.gz\n\n目录中最终样式：\n\n目录内部：\n\n2.4.端口配置与windows中类似\n2.5.启动在nacos&#x2F;bin目录中，输入命令启动Nacos：\nsh startup.sh -m standalone\n","categories":["教程"],"tags":["教程","Nacos"]},{"title":"微服务平台搭建","url":"/development-note/microservice/platform-build/","content":"\n\n微服务平台（后端）\n版本选择：\nSpring Boot: 2.5.7\nSpring Cloud:2020.0.5\n\nSpring Cloud gateway: 3.0.6\nSpring cloud Eureka: 3.0.5\n\n\n1. Eureka-Server 配置引入依赖：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\napplication.yml 文件：\nspring:  application:    name: guan-service-registerserver:  port: 8888eureka:  instance:    hostname: 127.0.0.1  client:    register-with-eureka: false    fetch-registry: false    serviceUrl:      defaultZone: http://localhost:$&#123;server.port&#125;/eureka/\n\n启动类：\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class ServiceRegisterApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ServiceRegisterApplication.class, args);    &#125;&#125;\n\n\n2. gateway 配置引入 maven 依赖：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--actuator 监控--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\napplication.yml 文件：\nserver:  port: 9000spring:  application:    name: guan-gateway  cloud:    gateway:      discovery:        locator:          enabled: true          lower-case-service-id: true      # 配置路由      routes:        - id: oauth          uri: lb://guan-auth          predicates:            - Path=/auth-api/**          filters:            - StripPrefix=1 # 跳过 1 级前缀，访问会映射到 lb://guan-auth/**logging:  pattern:    dateformat: HH:mm:ss.SSSeureka:  instance:    prefer-ip-address: true    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;  client:    service-url:      defaultZone: http://127.0.0.1:8888/eureka/# 开放所有页面节点，默认只开启 health、info 两个节点management:  endpoints:    web:      exposure:        include: &#x27;*&#x27;\n\n启动类：\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GatewayApplication.class, args);    &#125;&#125;\n\n\n3. 引入服务类以 guan-auth 为例\nmaven 依赖：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;edu.dublbo.platform&lt;/groupId&gt;        &lt;artifactId&gt;guan-common&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\napplication.yml 配置文件：\n# 服务启动的端口server:  port: 8000spring:  application:    name: guan-authlogging:  pattern:    console: &#x27;%d&#123;HH:mm:ss.SSS,CTT&#125; %level (%file:%line\\)- %m%n&#x27;eureka:  instance:    prefer-ip-address: true    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;  client:    # 注册到Eureka的注册中心#    register-with-eureka: true    # 获取注册实例列表#    fetch-registry: true    service-url:      # 配置注册中心地址      defaultZone: http://127.0.0.1:8888/eureka\n\n启动类：\nimport org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class GuanAuthApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GuanAuthApplication.class, args);    &#125;&#125;\n\n\n\n4. 测试访问auth服务：\n\n通过path访问：localhost:9000&#x2F;auth-api&#x2F;auth服务接口url\n通过spring.application.name访问：localhost:9000&#x2F;guan-auth&#x2F;auth服务接口url\n\n","categories":["研发笔记","微服务"],"tags":["教程","微服务"]},{"title":"Spring Boot踩坑记录","url":"/development-note/microservice/spring-boot/","content":"\n\n1.解决Spring Boot访问resources目录下的static资源问题\n下面从读、写两个方面解析访问static目录下的内容\n\n1.2 读取读取资源（也就是web端访问static资源）其实就很简单，Spring Boot 默认就配置了 &#x2F;static&#x2F;** 映射，所以无需任何配置就能访问。但是需要注意的是，如果使用了模板引擎（比如 thymeleaf），就需要手动配置，以下演示两种通过模板引擎访问static资源的方式：\n\n直接将资源在templates目录下，然后就能按路径访问，因为默认就会在templates目录下找静态资源那么访问hello.html可以直接：localhost:8080&#x2F;hello.html\n\n如果要直接访问resource&#x2F;static，那就需要在application.yml中添加如下配置，否则就会出现404\nspring:  mvc:    static-path-pattern: /static/**\n\n2. 写入也称上传资源，其实是不建议往resources目录下直接写入业务相关的文件（尤其是存储图片）的，因为后续可能会遇到\n\n资源的实时访问问题，比如上传图片后，然后再访问，可能需要重启才能继续访问\njar对resources目录进行保护措施，可能读取不到上传的资源\n\n但是有些极少量的文件需要存储到resources目录下，这就需要先获取到reources下的相应目录，此时应该考虑将来运行jar包时不能出错，因此我推荐一下两种方式获取static目录：\n\n通过ResourceUtils工具获取static目录\ntry &#123;    File staticDir = new File (ResourceUtils.getURL(&quot;classpath:static&quot;).getPath());&#125; catch (FileNotFoundException e) &#123;    // static 目录不存在！    e.printStackTrace();&#125;\n\n通过 ClassPathResource 获取\n// 这里要具体到你要访问的文件，然后拿到文件流对象，你就可以放肆操作了！ClassPathResource classPathResource = new ClassPathResource(&quot;/static/xxx/xxx.png&quot;);InputStream inputStream = classPathResource.getInputStream();// 转成字节数组final byte[] bytes = IOUtil.toByteArray(inputStream);// 比如把图片装成 base64 编码的字符串String imgStr = &quot;data:image/png;base64, &quot; + Base64.getEncoder().encodeToString(bytes);\n\n1.3 小结最后还想说一下，如果要上传图片，最好不要直接在jar包里上传图片，应该考虑：\n\n建立专门的静态资源服务器（图片服务器）可以使用nginx\n\n其次可以考虑做成本地硬盘上的映射目录：\n\n添加配置文件WebMVCConfig，然后在添加资源映射:\n@Slf4j@Configurationpublic class WebMVCConfig implements WebMvcConfigurer &#123;        @Value(&quot;$&#123;logo-img.request-path&#125;&quot;)    private String logoReqPath; // 请求地址    @Value(&quot;$&#123;logo-img.local-path&#125;&quot;)    private String logoLocPath; // 本地存放资源目录的绝对路径\t    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        File logoDir = new File(logoLocPath);        boolean flag = false;        if (!logoDir.exists())            flag = logoDir.mkdirs();        if (flag)            log.info(&quot;已成功创建资源 logo 目录：&#123;&#125;&quot;, logoLocPath);        log.info(&quot;getAbsolutePath = &#123;&#125;&quot;, logoDir.getAbsolutePath());        log.info(&quot;getPath = &#123;&#125;&quot;, logoDir.getPath());                registry.addResourceHandler(logoReqPath)                .addResourceLocations(&quot;file:&quot; + logoDir.getAbsolutePath() + File.separator);    &#125;&#125;\n\n上述参数在application.yml配置如下：\n\n最后访问 /logo-view-s/xxx.png 就会映射到 D:/test/logos/xxx.png\n\n\n\n\n2.减少Spring Boot微服务项目maven打包的体积对于很多部署在一个局域网的众多微服务而言，很多jar包都重复出现，对此，可以设立一个公共的jar包中心，这样就能在业务项目打包时，去除所有第三方jar包，只将自己的业务代码打包，如此一来，必能减少打包的体积！\n2.1 修改pom文件中maven插件部分&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;!-- 原来的打包方式 --&gt;            &lt;!--&lt;configuration&gt;                &lt;excludes&gt;                    &lt;exclude&gt;                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;                    &lt;/exclude&gt;                &lt;/excludes&gt;            &lt;/configuration&gt;--&gt;                        &lt;configuration&gt;                &lt;mainClass&gt;edu.dublbo.auth.GuanAuthApplication&lt;/mainClass&gt;                &lt;layout&gt;ZIP&lt;/layout&gt;                &lt;includes&gt;                    &lt;!-- 去除所有第三发jar包（nothing就是不要包含任何jar包） --&gt;                    &lt;include&gt;                        &lt;groupId&gt;nothing&lt;/groupId&gt;                        &lt;artifactId&gt;nothing&lt;/artifactId&gt;                    &lt;/include&gt;                &lt;/includes&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;!-- 进行重新打包 --&gt;                        &lt;goal&gt;repackage&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n\n2.2 运行jar执行结果重新对比，主要的变化就是lib目录下所有第三方的jar全部没有，当然如果要运行，就必须重新引入lib目录，也就是要让类加载器找到这些类。\n[nohup] java -Dloader.path=&#x27;第三方jar包所在目录&#x27; -jar 运行的jar包## 例如：nohup java -Dloader.path=&quot;/root/workspace/myjars/lib/&quot; -jar guan-auth-1.0.jar &gt; /root/workspace/logs/auth/guan-auth.log 2&gt;&amp;1 &amp;\n\n\n2.3 参考资料\nhttps://www.cnblogs.com/youcong/p/13548730.html\n\n","categories":["研发笔记","微服务"],"tags":["Spring Boot","踩坑记录"]}]